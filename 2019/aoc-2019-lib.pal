; ADVENT OF CODE 2019
;
; LIBRARY CODE
;

        .EVEN

;
; COPY(START,END,DEST)
;
; COPY MEMORY FROM START TO END TO DEST
;
COPY:
        MOV     R0,-(SP)        ; SAVE R0
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2

        MOV     10(SP),R0       ; R0 <- START
        MOV     12(SP),R1       ; R1 <- END
        MOV     14(SP),R2       ; R2 <- DEST

C0:     CMP     R0,R1           ; ARE WE DONE
        BEQ     C1              ; IF SO, SKIP
        MOV     (R0)+,(R2)+     ; COPY WORD TO DEST
        BR      C0              ; NEXT
C1:
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        MOV     (SP)+,R0        ; RESTORE R0
        RTS     PC              ; RETURN TO CALLER

;
; FMTWU (VALUE, OUT)
;
; FORAMT AN UNSIGNED WORD TO DECIMAL, CALLING THE OUT SUBROUTINE
; FOR EACH DIGIT.
;
FMTWU:   MOV    R2,-(SP)        ; SAVE R2
         MOV    R3,-(SP)        ; SAVE R3
         MOV    R4,-(SP)        ; SAVE R4
         MOV    10(SP),R0       ; R0 <- VALUE
         MOV    12(SP),R3       ; R3 <- OUT SUBROUTINE
         CLR    R4              ; R4 <- COUNTER (0)

F1:      MOV    #12,-(SP)       ; PUSH DIVISOR (10D)
         MOV    R0,-(SP)        ; PUSH DIVIDEND (VALUE)
         JSR    PC,DIVWU        ; DIVWU (VALUE, 10D)
         ADD    #4,SP           ; CLEAN UP STACK
         ADD    #60,R1          ; CONVERT REMAINDER TO CHAR
         MOVB   R1,-(SP)        ; PUSH DIGIT TO STACK
         INC    R4              ; INCREMENT THE COUNTER
         TST    R0              ; CHECK THE QUOTIENT
         BNE    F1              ; IF NOT ZERO, MOVE TO NEXT DIGIT

F2:      JSR    PC,(R3)         ; OUT(CHAR) CHAR ALREADY ON STACK
         TSTB   (SP)+           ; POP CHAR TO NOWHERE
         DEC    R4              ; DECREMENT THE COUNTER
         BNE    F2              ; MOVE TO NEXT DIGIT

         MOV    10(SP),R0       ; RETURN ORIGINAL VALUE
         MOV    (SP)+,R4        ; RESTORE R4
         MOV    (SP)+,R3        ; RESTORE R3
         MOV    (SP)+,R2        ; RESTORE R2
         RTS    PC              ; RETURN TO CALLER

;
; FMTDU (VALUE HI, VALUE LO, STREAM)
;
; FORAMT AN UNSIGNED DOUBLE WORD TO DECIMAL, CALLING THE OUT SUBROUTINE
; FOR EACH DIGIT.
;
FMTDU:
        MOV     R0,-(SP)        ; SAVE R0
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4

        SUB     #10,SP          ; SPACE FOR RESULT
        SUB     #12,SP          ; SPACE FOR OUTPUT BUFFER

        MOV     36(SP),R0       ; R0 <- VALUE HI
        MOV     40(SP),R1       ; R1 <- VALUE LO
        MOV     SP,R2           ; R2 <- RESULT ADDRESS
        ADD     #12,R2          ;    "
        MOV     SP,R3           ; R3 <- BUFFER
        CLR     R4              ; R4 <- COUNTER

FF1:    MOV     R2,-(SP)        ; PUSH RESULT ADDRESS
        MOV     #12,-(SP)       ; PUSH DIVISOR LO 10(10)
        CLR     -(SP)           ; PUSH DIVISOR HI  0
        MOV     R1,-(SP)        ; PUSH DIVIDEND LO
        MOV     R0,-(SP)        ; PUSH DIVIDEND HI
        JSR     PC,DIVDU        ; DIVIDE
        ADD     #12,SP          ; CLEAN UP STACK
        MOV     12(SP),R0       ; STORE QUOTIENT HI IN R0
        MOV     14(SP),R1       ; STORE QUOTIENT LO IN R1

        ADD     #60,20(SP)      ; CONVERT REMAINDER TO DECIMAL DIGIT
        MOVB    20(SP),(R3)+    ; PUSH CHARACTER TO BUFFER
        INC     R4              ; INCREMENT COUNTER
        TST     R1              ; IS QUOTIENT LO ZERO?
        BNE     FF1             ; NO, REPEAT
        TST     R0              ; IS QUOTIENT HI ZERO?
        BNE     FF1             ; NO, REPEAT

FF2:
        MOV     42(SP),-(SP)    ; STREAM
        MOVB    -(R3),-(SP)     ; PUSH CHAR
        JSR     PC,FPUTC        ; FPUTC(C, STREAM)
        ADD     #4,SP           ; CLEAN UP STACK
        DEC     R4              ; DECREMENT COUNTER
        BNE     FF2             ; IF NOT DONE, NEXT CHAR

        ADD     #12,SP          ; RELENQUISH BUFFER SPACE
        ADD     #10,SP          ; RELENQUISH RESULT SPACE
        MOV     (SP)+,R4        ; RESTORE R4
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        MOV     (SP)+,R0        ; RESTORE R0
        RTS     PC              ; RETURN TO CALLER

; PRSWU (STREAM) -> R0: HI, R1: LO
;
; PARSE A 32 BIT VALUE FROM DECIMAL STRING FROM THE STREAM
PRSWU:  MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4
        MOV     R5,-(SP)        ; SAVE R5
        MOV     12(SP),R5       ; R5 <- IN

        CLR     R0              ; CLEAR R0
        CLR     R1              ; CLEAR R1
        CLR     R2              ; CLEAR HI RESULT
        CLR     R3              ; CLEAR LO RESULT

P101:   MOV     R5,-(SP)        ; STREAM = R5
        JSR     PC,FGETC        ; FGETC(STREAM)
        CLR     (SP)+           ; CLEAN UP STACK
        TST     R0              ; WAS EOF RETURNED?
        BPL     P104            ; NO, CONTINUE
        SEC                     ; SET THE CARRY (ERROR) FLAG
        BR      P102            ; DONE
P104:   MOV     R0,R4           ; STASH BYTE IN R4
        CMP     R0,#60          ; IS IT LESS THAN '0'?
        BMI     P103            ;   YES, DONE
        CMP     #71,R0          ; IS IT GREATER THAN '9'?
        BMI     P103            ;   YES, DONE
        SUB     #60,R4          ; CONVERT ASCII TO INT

        ; THIS SECTION IMPLEMENTS R2R3 = R2R3 * 10D + R4
        MOV     R4,-(SP)        ; STASH THE NEW DIGIT
        MOV     R3,-(SP)        ; PUSH LO RESULT
        MOV     #12,-(SP)       ; PUSH 10D
        JSR     PC,MULWU        ; MULWU (LO,10D) -> R0R1
        ADD     #4,SP           ; CLEAN UP STACK
        MOV     R1,R3           ; LO RESULT = LO(LO* 10D)
        MOV     R0,R4           ; CARRY = HI(LO * 10D)

        MOV     R2,-(SP)        ; PUSH HI RESULT
        MOV     #12,-(SP)       ; PUSH 10D
        JSR     PC,MULWU        ; MULWU (HI,10D) -> R0R1
        ADD     #4,SP           ; CLEAN UP STACK
        MOV     R1,R2           ; HI RESULT = LO(HI * 10D)
        ADD     R4,R2           ; HI RESULT += CARRY

        MOV     (SP)+,R4        ; RESTORE NEW DIGIT TO R4
        ADD     R4,R3           ; ADD IT TO LO RESULT
        ADC     R2              ; ADD ANY CARRY TO HI (PROB. NOT USED)

        BR      P101            ; NEXT DIGIT

P103:   MOV     R5,-(SP)        ; STREAM = R5
        MOV     R0,-(SP)        ; C = R0
        JSR     PC,UNGETC       ; UNGETC(C, STREAM)
        ADD     #4,SP           ; CLEAN UP STACK
        CLC                     ; CLEAR ERROR INDICATOR
P102:   MOV     R2,R0           ; HI RESULT <- R2
        MOV     R3,R1           ; LO RESULT <- R3
        MOV     (SP)+,R5        ; RESTORE R5
        MOV     (SP)+,R4        ; RESTORE R4
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        RTS     PC              ; RETURN TO CALLER

;
; UNISTD
;

; ssize_t read(int fildes, void *buf, size_t nbyte);
;
; READ FROM A FILE
;
READ:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2

        MOV     6(SP),R1        ; R1 <- FILEDES
        ASL     R1              ; MULTIPLY BY 2
        MOV     FDTABL(R1),R2   ; R2 <- FDTABL ENTRY
        MOV     (R2),R2         ; R2 <- DEVICE READ

        MOV     12(SP),-(SP)    ; PUSH NBYTE
        MOV     12(SP),-(SP)    ; PUSH BUF
        MOV     R1,-(SP)        ; PUSH FILEDES
        JSR     PC,(R2)         ; CALL DEVICE READ
        ADD     #6,SP           ; CLEAN UP STACK

        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

; ssize_t write(int fildes, const void *buf, size_t nbyte);
;
; WRITE ON A FILE
;
WRITE:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2

        MOV     6(SP),R1        ; R1 <- FILEDES
        ASL     R1              ; MULTIPLY BY 2
        MOV     FDTABL(R1),R2   ; R2 <- FDTABL ENTRY
        MOV     2(R2),R2        ; R2 <- DEVICE WRITE

        MOV     12(SP),-(SP)    ; PUSH NBYTE
        MOV     12(SP),-(SP)    ; PUSH BUF
        MOV     R1,-(SP)        ; PUSH FILEDES
        JSR     PC,(R2)         ; CALL DEVICE WRITE
        ADD     #6,SP           ; CLEAN UP STACK

        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

;
; STDIO
;

; int fputc(int c, FILE *stream);
;
; PUT A BYTE ON A STREAM
;
FPUTC:
        MOV     SP,R0           ; R0 <- SP
        ADD     #2,R0           ; R0 <- LOCATION OF C

        MOV     #1,-(SP)        ; NBYTE = 1
        MOV     R0,-(SP)        ; BUF = LOCATION OF C
        MOV     @10(SP),-(SP)   ; FD = stream->fd
        JSR     PC,WRITE        ; WRITE(FD, BUF, NBYTE)
        ADD     #6,SP           ; CLEAN UP STACK

        RTS     PC              ; RETURN TO CALLER

; int putchar(int c);
;
; PUT A BYTE ON A STDOUT STREAM
;
PUTCHR:
        MOV     #STDOUT,-(SP)  ; STREAM = STDOUT
        MOV     4(SP),-(SP)    ; C = C
        JSR     PC,FPUTC       ; FPUTC(C, STREAM)
        ADD     #4,SP          ; CLEAN UP STACK
        RTS     PC             ; RETURN TO CALLER

; int fgetc(FILE *stream);
; int getc(FILE *stream);
;
; GET A BYTE FROM A STREAM
;
FGETC:
GETC:
        MOV     2(SP),R0        ; R0 <- STREAM
        ADD     #2,R0           ; R0 <- UNGETC BUFFER
        TST     (R0)            ; SET STATUS FROM UNGETC BUFFER
        BPL     FGETC1          ; IF EMPTY, GET FROM UNDERLYING FILE
        BIC     #100000,(R0)    ; CLEAR THE UNGETC BUFFER FULL BIT
        MOV     (R0),R0         ; RETURN THE BYTE FROM THE UNGETC BUF
        BR      FGETC9          ; WE'RE DONE

FGETC1: CLR     -(SP)           ; SPACE FOR BUFFER
        MOV     SP,R0           ; R0 <- LOCATION OF BUFFER

        MOV     #1,-(SP)        ; NBYTE = 1
        MOV     R0,-(SP)        ; BUF = LOCATION OF BUFFER
        MOV     @10(SP),-(SP)   ; FD = stream->fd
        JSR     PC,READ         ; READ(FD, BUF, NBYTE)
        ADD     #6,SP           ; CLEAN UP STACK
        TST     R0              ; IS R0 ZERO?
        BNE     FGETC8          ; NO, SKIP
        MOV     #-1,(SP)        ; RETURN EOF
FGETC8: MOV     (SP)+,R0        ; COPY BUFFER TO R0
FGETC9: RTS     PC              ; RETURN TO CALLER

; int ungetc(int c, FILE *stream);
;
; PUSH BYTE BACK INTO INPUT STREAM
;
UNGETC:
        MOV     4(SP),R0        ; R0 <- STREAM
        ADD     #2,R0           ; R0 <- UNGETC BUFFER
        TST     (R0)            ; SET STATUS FROM BUFFER
        BMI     UNGET1          ; BUFFER IS FULL, RETURN
        MOV     2(SP),(R0)      ; SAVE THE BYTE TO THE UNGETC BUFFER
        BIS     #100000,(R0)    ; SET THE UNGETC BUFFER FULL BIT
        MOV     2(SP),R0        ; RETURN THE PUSHED BYTE
        BR      UNGET9          ; WE'RE DONE
UNGET1: MOV     #-1,R0          ; RETURN -1
UNGET9: RTS     PC              ; RETURN TO CALLER

; int fputs(const char *restrict s, FILE *restrict stream);
;
; PUT A STRING ON A STREAM
;
FPUTS:
        MOV     2(SP),R0        ; R0 <- S
        TSTB    (R0)+           ; IS (R0) ZERO?
        BNE     .-2             ; NO, TRY NEXT BYTE
        SUB     2(SP),R0        ; R0 -= S

        MOV     R0,-(SP)        ; NBYTE = R0
        MOV     4(SP),-(SP)     ; BUF = S
        MOV     @10(SP),-(SP)   ; FILEDES = STREAM->fd
        JSR     PC,WRITE        ; WRITE(FILEDES, BUF, NBYTE)
        ADD     #6,SP           ; CLEAN UP STACK
        CLR     R0              ; RETURN NON-NEGATIVE
        RTS     PC              ; RETURN TO CALLER

;
; int fprintf(FILE *stream, char *format, ...)
;
; PRINT FORMATTED OUTPUT
; SUPPORTS %u, %i, %d, AND %% FORMATTING DIRECTIVES
;
FPRNTF:
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4
        MOV     10(SP),-(SP)    ; PUT STREAM AT SP, FOR FPUTC

        MOV     14(SP),R2       ; R2 <- FORMAT
        MOV     #16,R3          ; R3 <- POINTER TO NEXT ARG
        ADD     SP,R3

FPRNT0:
        TSTB    (R2)            ; CHECK FOR NULL
        BEQ     FPRNT9          ; IF SO, WE'RE DONE
        CMPB    #'%,(R2)        ; CHECK FOR %
        BEQ     FPRN00          ; IF SO, GO TO FORMAT SECTION
        MOVB    (R2)+,-(SP)     ; C <- NEXT CHAR
        JSR     PC,FPUTC        ; FPUTC(C, STREAM)
        ADD     #2,SP           ; POP C OFF STACK
        BR      FPRNT0          ; NEXT CHAR

FPRN00: CLR     R4              ; R4 <- CLEAR FLAGS
FPRNT1: INC     R2              ; NEXT CHAR
        TSTB    (R2)            ; IS IT NULL?
        BEQ     FPRNT9          ; IF SO, WE'RE DONE
        CMPB    #'%,(R2)        ; IS IT %
        BEQ     FPRNT2          ; HANDLE PERCENT
        CMPB    #'u,(R2)        ; IS IT u
        BEQ     FPRNT3          ; HANDLE UNSIGNED INT IN DECIMAL
        CMPB    #'i,(R2)        ; IS IT i
        BEQ     FPRNT4          ; HANDLE SIGNED INT IN DECIMAL
        CMPB    #'d,(R2)        ; IS IT d
        BEQ     FPRNT4          ; HANDLE SIGNED INT IN DECIMAL
        CMPB    #'l,(R2)        ; IS IT l
        BEQ     FPRNT5          ; HANDLE L LENGTH MODIFIER
        ; UNKNOWN FORMAT
        INC     R2              ; INC POINTER
        BR      FPRNT0          ; NEXT CHAR

FPRNT2:
        MOV     #'%,-(SP)       ; C <- %
        JSR     PC,FPUTC        ; FPUTC(C, STREAM)
        ADD     #2,SP           ; POP C OFF STACK
        INC     R2              ; INC POINTER
        BR      FPRNT0          ; NEXT CHAR

FPRNT3:
        SUB     #4,SP           ; MAKE SPACE FOR TWO WORDS
        BIT     #1,R4           ; IS THE LENGTH MODIFIER SET?
        BNE     FPRN30          ; YES, SKIP AHEAD TO PUSH HI
        CLR     (SP)            ; HI <- 0
        BR      FPRN31          ; MOVE ALONG
FPRN30: MOV     (R3)+,(SP)      ; HI <- ARG
FPRN31: MOV     (R3)+,2(SP)     ; LO <- ARG
        JSR     PC,FMTDU        ; FMTDU (HI, LO, STREAM)
        ADD     #4,SP           ; POP HI AND LO OFF STACK
        INC     R2              ; INC FORMAT POINTER
        BR      FPRNT0          ; NEXT CHAR
FPRNT4:
        TST     (R3)            ; IS IT NEGATIVE?
        BPL     FPRNT3          ; NO, PRINT UNSIGNED
        BIT     #1,R4           ; IS THE LENGTH MODIFIER SET?
        BNE     FPRN40          ; YES, SKIP AHEAD TO COMPLIMENT DW
        NEG     (R3)            ; NEGATE VALUE
        BR      FPRN41          ; MOVE ALONG
FPRN40: COM     (R3)            ; COMPLIMENT HI
        COM     2(R3)           ; COMPLIMENT LO
        ADD     #1,2(R3)        ; INCREMENT LO
        ADC     (R3)            ; ADD CARRY TO HI
FPRN41: MOV     #'-,-(SP)       ; C <- -
        JSR     PC,FPUTC        ; FPUTC(C, STREAM)
        CLR     (SP)+           ; POP C OFF STACK
        BR      FPRNT3          ; PRINT UNSIGNED

FPRNT5:
        BIS     #1,R4           ; SET THE L BIT
        BR      FPRNT1          ; NEXT CONVERSION SPECIFIER
FPRNT9:
        CLR     (SP)+           ; POP STREAM
        MOV     (SP)+,R4        ; RESTORE R4
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        RTS     PC              ; RETURN TO CALLER


;
; KL11 TELETYPE DRIVER
;
        TKS=    177560          ; TELETYPE KEYBOARD STATUS
        TKB=    177562          ; TELETYPE KEYBOARD BUFFER
        TPS=    177564          ; TELEPRINTER STATUS WORD
        TPB=    177566          ; TELEPRINTER BUFFER

; ssize_t read(int fildes, void *buf, size_t nbyte);
;
; READ FROM A KL11 TELETYPE CONTROLLER
;
TTIRD:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
                                ; STACK:
                                ;  0: R2
                                ;  2: R1
                                ;  4: RETURN ADDRESS
                                ;  6: FILEDES
                                ; 10: BUF
                                ; 12: NBYTE
        MOV     12(SP),R1       ; R1 <- NBYTE
        MOV     10(SP),R2       ; R2 <- BUF
        CLR     R0              ; R0 <- BYTES READ
        TST     R1              ; IS NBYTE ZERO?
TTIRD1: BEQ     TTIRD9          ; YES, WE'RE DONE
        BIS     #1,TKS          ; SET RDR ENB
        TSTB    TKS             ; IS DONE SET?
        BPL     .-4             ; NO, TRY AGAIN
        MOVB    TKB,(R2)        ; COPY TO BUF
        ; TODO: IOCTL OR TCSETATTR TO CONTROL ECHO
        TSTB    TPS             ; IS TELEPRINTER READY?
        BPL     .-4             ; NO, TRY AGAIN
        MOVB    (R2)+,TPB       ; ECHO TO TELEPRINTER
        INC     R0              ; INCREMENT READ BYTE COUNT
        DEC     R1              ; DECREMENT COUNT OF REMAINING BYTES
        BR      TTIRD1          ; NEXT BYTE
TTIRD9:
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

; ssize_t write(int fildes, const void *buf, size_t nbyte);
;
; WRITE ON A Kl11 TELETYPE CONTROLLER
;
TTOWR:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
                                ; STACK:
                                ;  0: R2
                                ;  2: R1
                                ;  4: RETURN ADDRESS
                                ;  6: FILEDES
                                ; 10: BUF
                                ; 12: NBYTE
        CLR     R0              ; R0 <- BYTES READ (0)
        MOV     12(SP),R1       ; R1 <- NBYTE
        MOV     10(SP),R2       ; R2 <- BUF

        TST     R1              ; IS NBYTE ZERO?
TTOWR1: BEQ     TTOWR9          ; IF SO, WE'RE DONE
        TSTB    TPS             ; IS TELEPRINTER READY?
        BPL     .-4             ; NO, TRY AGAIN
        MOVB    (R2)+,TPB       ; WRITE BYTE TO TELEPRINTER
        INC     R0              ; INCREMENT BYTE READ COUNT
        DEC     R1              ; DECREMENT COUNT OF REMAINING BYTES
        BR      TTOWR1          ; NEXT BYTE

TTOWR9: MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R2
        RTS     PC              ; RETURN TO CALLER

;
; PC11 HIGH-SPEED PAPER TAPE READER/PUNCH DRIVER
;
        PRS=    177550          ; PAPER TAPE READER STATUS WORD
        PRB=    177552          ; PAPER TAPE READER BUFFER
        PPS=    177554          ; PAPER TAPE PUNCH STATUS WORD
        PPB=    177556          ; PAPER TAPE PUNCH BUFFER

; ssize_t read(int fildes, void *buf, size_t nbyte);
;
; READ FROM A PC11 PAPER TAPE READER CONTROLLER
;
PTRRD:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2

        MOV     12(SP),R1       ; R1 <- NBYTE
        MOV     10(SP),R2       ; R2 <- BUFFER
        CLR     R0              ; R0 <- COUNT OF BYTES READ (0)

        TST     R1              ; IS R1 ZERO?
PTRRD1: BEQ     PTRRD9          ; IF SO, WE'RE DONE
        BIS     #1,PRS          ; SET RDR ENB
        BIT     #100200,PRS     ; CHECK FOR ERROR OR DONE
        BEQ     .-6             ; IF NIETHER, TRY AGAIN
        BMI     PTRRD9          ; IF ERROR, WE'RE DONE
        MOVB    PRB,(R2)+       ; READ BYTE INTO BUFFER
        INC     R0              ; INCREMENT BYTES READ COUNT
        DEC     R1              ; DECREMENT BYTES REMAINING COUNT
        BR      PTRRD1          ; NEXT BYTE

PTRRD9: MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER


; ssize_t write(int fildes, void *buf, size_t nbyte);
;
; WRITE ON A PC11 PAPER TAPE PUNCH CONTROLLER
;
PTPWR:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2

        MOV     12(SP),R1       ; R1 <- NBYTE
        MOV     10(SP),R2       ; R2 <- BUFFER
        CLR     R0              ; R0 <- COUNT OF BYTES READ (0)

        TST     R1              ; IS R1 ZERO?
PTPWR1: BEQ     PTPWR9          ; IF SO, WE'RE DONE
        BIT     #100200,PPS     ; CHECK FOR ERROR OR READY
        BEQ     .-6             ; IF NEITHER, TRY AGAIN
        BMI     PTPWR9          ; IF ERROR, WE'RE DONE
        MOVB    (R2)+,PPB       ; WRITE BYTE TO PUNCH
        INC     R0              ; INCREMENT BYTES READ COUNT
        DEC     R1              ; DECREMENT BYTES REMAINING COUNT
        BR      PTPWR1          ; NEXT BYTE

PTPWR9: MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER
;
; NULL DEVICE DRIVER
;
; ssize_t read(int fildes, void *buf, size_t nbyte);
; ssize_t write(int fildes, const void *buf, size_t nbyte);
;
; READ FROM A NULL STREAM
; WRITE ON A NULL STREAM
;
NULRD:
NULWR:
        CLR     R0              ; NO BYTES READ OR WRITTEN
        RTS     PC              ; RETURN TO CALLER


; FILE DESCRIPTOR TABLE
FDTABL:
        .WORD   TTI             ; FD 0: TTY IN
        .WORD   TTO             ; FD 1: TTY OUT
        .WORD   TTO             ; FD 2: ERRORS -> TTY OUT
        .WORD   PTR             ; FD 3: PTR IN
        .WORD   PTP             ; FD 4: PTP OUT
        .WORD   0               ; END OF TABLE

; FILE DESCRIPTOR TABLE ENTRY STRUCTURE
; 0: READ SUBROUTINE
; 2: WRITE SUBROUTINE
; 4: UNIT

TTI:
        .WORD   TTIRD
        .WORD   NULWR
        .WORD   0

TTO:
        .WORD   NULRD
        .WORD   TTOWR
        .WORD   0

PTR:
        .WORD   PTRRD
        .WORD   NULWR
        .WORD   0

PTP:    .WORD   NULRD
        .WORD   PTPWR
        .WORD   0

;
; OPEN STREAMS
;
; FILE STREAM STRUCTURE
;  0: FD
;  2: UNGETC BUFFER

STDIN:  .WORD   0
        .WORD   0
STDOUT: .WORD   1
        .WORD   0
STDERR: .WORD   2
        .WORD   0
PTIN:   .WORD   3
        .WORD   0
PTOUT:  .WORD   4
        .WORD   0


;
; MATH
;

; MULWS(MULTIPLIER, MULTIPLICAND): R0, R1
;
; MULTIPLY WORDS SIGNED
;
; R0: RESULT HI
; R1: RESULT LO
MULWS:  MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4

        CLR     R4              ; CLEAR RESULT SIGN BIT
        MOV     10(SP),R0       ; MOVE MULTIPLIER TO R0
        MOV     12(SP),R2       ; MOVE MULTIPLICAND TO R2

        TST     R0              ; TEST THE MULTIPLIER
        BPL     MULWS0          ; IF NOT NEGATIVE, SKIP TO MULTIPLICAND
        NEG     R0              ; MAKE THE MULTIPLIER POSITIVE
        COM     R4              ; FLIP THE RESULT SIGN BIT

MULWS0: TST     R2              ; TEST THE MULTIPLICAND
        BPL     MULWU0          ; IF NOT NEG, SKIP TO SHIFT-AND-ADD
        NEG     R2              ; MAKE THE MULTIPLICAND POSITIVE
        COM     R4              ; FLIP THE RESULT SIGN BIT
        BR      MULWU0          ; BRANCH TO THE SHIFT-AND-ADD SECTION

; MULWU(MULTIPLIER, MULTIPLICAND): R0, R1
;
; MULTIPLY WORDS UNSIGNED
;
; R0: RESULT HI
; R1: RESULT LO
MULWU:  MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4

        CLR     R4              ; CLEAR RESULT SIGN BIT
        MOV     10(SP),R0       ; MOVE MULTIPLIER TO R0
        MOV     12(SP),R2       ; MOVE MULTIPLICAND TO R2
MULWU0: MOV     #20,R3          ; SET R3 COUNTER TO 16
        CLR     R1              ; CLEAR RESULT LO

MULWU1: ASL     R1              ; SHIFT LEFT RESULT LO
        ROL     R0              ; ROTATE LEFT RESULT HI
        BCC     MULWU2          ; CARRY CLEAR: NO NEED TO ADD
        ADD     R2,R1           ; ADD MULTIPLICAND TO RESULT LO
        ADC     R0              ; ADD CARRY (IF ANY) TO RESULT HI

MULWU2: DEC     R3              ; DECREMENT COUNT
        BNE     MULWU1          ; IF NOT DONE, NEXT DIGIT

        TST     R4              ; CHECK THE RESULT SIGN BIT
        BPL     MULWU9          ; IF NOT SET, SKIP TO THE END
        COM     R0              ; COMPLIMENT RESULT HI
        NEG     R1              ; TWO'S COMPLIMENT RESULT LO
MULWU9:
        MOV     (SP)+,R4        ; RESTORE R4
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        RTS     PC

;
; MULPU (M'CAND HI, M'CAND LO, MULTIPLIER HI, MULTIPLIER LO) ->
;   R0: HI(LO(PRODUCT)), R1: LO(LO(PRODUCT))
;
; RETURN LOW 32 BITS OF A 32 BIT TIMES 32 BIT PARTIAL PRODUCT
;
; R1 = LO(LO(A) * LO(B))
; R0 = HI(LO(A) * LO(B)) + LO(LO(A) * HI(B)) + LO (HI(A) * LO(B))
MULPU:
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV    10(SP),-(SP)     ; PUSH LO(A): MULTIPLICAND LO
        MOV    16(SP),-(SP)     ; PUSH LO(B): MULTIPLIER LO
        JSR    PC,MULWU         ; MULTIPLY LO(A) * LO(B)
        MOV    R1,R3            ; R3 <- LO(LO(A) * LO(B))
        MOV    R0,R2            ; R2 <- HI(LO(A) * LO(B))

        MOV    16(SP),(SP)      ; HI(B): MULTIPLIER HI
        JSR    PC,MULWU         ; MULTIPLY LO(A) * HI(B)
        ADD    R1,R2            ; R2 += LO(LO(A) * HI(B))

        MOV    12(SP),(SP)      ; HI(A): MULTIPLICAND HI
        MOV    20(SP),2(SP)     ; LO(B): MULTIPLIER LO
        JSR    PC,MULWU         ; MULTIPLY HI(A) * LO(B)
        ADD    R1,R2            ; R2 += LO(HI(A) * LO(B))
        ADD    #4,SP            ; CLEAN UP STACK

        MOV    R2,R0            ; RESULT HI
        MOV    R3,R1            ; RESULT LO

        MOV    (SP)+,R3         ; RESTORE R3
        MOV    (SP)+,R2         ; RESTORE R2
        RTS    PC               ; RETURN TO CALLER

;
; MULPS (M'CAND HI, M'CAND LO, MULTIPLIER HI, MULTIPLIER LO) ->
;   R0: HI(LO(PRODUCT)), R1: LO(LO(PRODUCT))
;
; RETURN LOW 32 BITS OF A 32 BIT TIMES 32 BIT PARTIAL PRODUCT, SIGNED
;
MULPS:
        MOV     R5,-(SP)        ; SAVE R5
        CLR     R5              ; R5 <- NEGATIVE FLAG
        TST     4(SP)           ; CHECK HI(MULTIPLICAND)
        BPL     MULPS1          ; IF POSITIVE, SKIP
        COM     4(SP)           ; COMPLIMENT HI(MULTIPLICAND)
        COM     6(SP)           ; COMPLIMENT LO(MULTIPLICAND)
        ADD     #1,6(SP)        ; INCREMENT LO(MULTIPICAND)
        ADC     4(SP)           ; ADD CARRY TO HI(MULTIPLICAND)
        INC     R5              ; TOGGLE NEGATIVE FLAG
MULPS1: TST     10(SP)          ; CHECK HI(MULTIPLIER)
        BPL     MULPS2          ; IF POSITIVE, SKIP
        COM     10(SP)          ; COMPLIMENT HI(MULTIPLIER)
        COM     12(SP)          ; COMPLIMENT LO(MULTIPLIER)
        ADD     #1,12(SP)       ; INCREMENT LO(MULTIPLIER)
        ADC     10(SP)          ; ADD CARRY TO HI(MULTIPLIER)
        INC     R5              ; TOGGLE NEGATIVE FLAG
MULPS2:
        MOV     12(SP),-(SP)    ; LO(MULTIPLIER)
        MOV     12(SP),-(SP)    ; HI(MULTIPLIER)
        MOV     12(SP),-(SP)    ; LO(MULTIPLICAND)
        MOV     12(SP),-(SP)    ; HI(MULTIPLICAND)
        JSR     PC,MULPU        ; MULPU(H,L,H,L)
        ADD     #10,SP          ; CLEAN UP STACK

        BIT     #1,R5           ; CHECK THE NEGATIVE FLAG
        BEQ     MULPS9          ; IF CLEAR, DONE
        COM     R0              ; COMPLIMENT HI(RESULT)
        COM     R1              ; COMPLIMENT LO(RESULT)
        ADD     #1,R1           ; INCREMENT LO(RESULT)
        ADC     R0              ; ADD CARRY TO HI(RESULT)
MULPS9:
        MOV     (SP)+,R5        ; RESTORE R5
        RTS     PC              ; RETURN TO CALLER

;
; DIVWS (DIVIDEND, DIVISOR) -> R0: QUOTIENT, R1: REMAINDER
;
; SIGNED 16-BIT DIVISION
;
DIVWS:  MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4

        CLR     R2              ; CLEAR FLAGS REGISTER
        MOV     10(SP),R0       ; R0 <- DIVIDEND
        MOV     12(SP),R3       ; R3 <- DIVISOR

        TST     R3              ; CHECK DIVISOR
        BPL     DIVWS0          ; IF POSITIVE, SKIP AHEAD
        INC     R2              ; FLIP FLAG BIT 0 (SIGNS DIFFER)
        NEG     R3              ; MAKE DIVISOR POSITIVE
DIVWS0: TST     R0              ; CHECK DIVIDEND
        BPL     DIVWU0          ; IF POSITIVE, SKIP TO UNSIGNED DIVIDE
        INC     R2              ; FLIP FLAG BIT 0 (SIGNS DIFFER)
        BIS     #4,R2           ; SET FLAG BIT 2 (DIVIDEND NEGATIVE)
        NEG     R0              ; MAKE DIVIDEND POSITIVE
        BR      DIVWU0          ; UNSIGNED DIVIDE LOOP

; DIVWU (DIVIDEND, DIVISOR) -> R0: QUOTIENT, R1: REMAINDER
;
; UNSIGNED 16-BIT DIVISION
;
DIVWU:  MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4

        CLR     R2              ; R2 <- FLAGS
        MOV     10(SP),R0       ; R0 <- DIVIDEND
        MOV     12(SP),R3       ; R3 <- DIVISOR
DIVWU0: TST     R3              ; CHECK THE DIVISOR
        BNE     DIVWU1          ; IF NOT ZERO, CONTINUE
        SEV                     ; ERROR: SET OVERFLOW
        BR      DIVWU9          ; CLEAN UP AND EXIT
DIVWU1: CLR     R1              ; R1 <- REMAINDER
        MOV     #20,R4          ; R4 <- COUNTER

DIVWU2: ASL     R0              ; SHIFT DIVIDEND AND QUOTIENT LEFT
        ROL     R1              ; ROTATE REMAINDER LEFT, WITH CARRY
        CMP     R1,R3           ; IS DIVISOR <= REMAINDER?
        BMI     DIVWU3          ; NO, CONTINUE
        SUB     R3,R1           ; REMAINDER -= DIVISOR
        INC     R0              ; SET LOW BIT IN QUOTIENT
DIVWU3: DEC     R4              ; DEC COUNTER
        BNE     DIVWU2          ; IF NOT ZERO, REPEAT
        CLV                     ; INDICATE NO ERROR

        BIT     #4,R2           ; CHECK THE DIVIDEND NEGATIVE FLAG
        BEQ     DIVWU8          ; IF NOT SET, SKIP AHEAD
        INC     R0              ; INCREMENT THE QUOTIENT
        SUB     R3,R1           ; SUBTRACT DIVISOR FROM REMAINDER
        NEG     R1              ; MAKE REMAINDER POSITIVE
DIVWU8: BIT     #1,R2           ; CHECK THE QUOTIENT NEGATIVE FLAG
        BEQ     DIVWU9          ; IF NOT SET, SKIP AHEAD
        NEG     R0              ; MAKE QUOTIENT NEGATIVE

DIVWU9: MOV     (SP)+,R4        ; RESTORE R4
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        RTS     PC              ; RETURN TO CALLER

; DIVDU (DIVIDEND HI, DIVIDEND LO, DIVISOR HI, DIVISOR LO, RESULT)
; (RESULT) -> QUOTIENT HI, QUOTIENT LO, REMAINDER HI, REMAINDER LO
;
; UNSIGNED 32-BIT DIVISION
;
DIVDU:
        TST     10(SP)          ; CHECK DIVISOR LO
        BNE     DA1             ; IF NOT ZERO, CONTINUE
        TST     6(SP)           ; CHECK DIVISOR HI
        BNE     DA1             ; IF NOT ZERO, CONTINUE
        SEV                     ; SET OVERFLOW (ERROR)
        RTS     PC              ; RETURN TO CALLER
DA1:
        MOV     R0,-(SP)        ; SAVE R0
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4

        MOV     22(SP),R0       ; R0 <- RESULT
        MOV     12(SP),R2       ; R2 <- DIVIDEND HI
        MOV     14(SP),R3       ; R3 <- DIVIDEND LO
        MOV     #40,R4          ; R4 <- COUNTER
        CLR     (R0)            ; CLEAR QUOTIENT HI
        CLR     2(R0)           ; CLEAR QOUTIENT LO
        CLR     4(R0)           ; CLEAR REMAINDER HI
        CLR     6(R0)           ; CLEAR REMAINDER LO
DA2:
        ASL     2(R0)           ; SHIFT QUOTIENT LO LEFT
        ROL     (R0)            ; ROTATE QUOTIENT HI LEFT WITH CARRY
        ASL     R3              ; SHIFT DIVIDEND LO LEFT
        ROL     R2              ; ROTATE DIVIDEND HI LEFT WITH CARRY
        ROL     6(R0)           ; ROTATE REMAINDER LO LEFT WITH CARRY
        ROL     4(R0)           ; ROTATE REMAINDER HI LEFT WITH CARRY
        CMP     4(R0),16(SP)    ; COMPARE REMAINDER HI AND DIVISOR HI
        BMI     DA3             ; IF DIVISOR HI > REMAINDER HI, CONT
        BNE     DA4
        CMP     6(R0),20(SP)    ; COMPARE REMAINDER LO AND DIVISOR LO
        BMI     DA3             ; IF DIVISOR LO > REMAINDER LO, CONT
DA4:    SUB     20(SP),6(R0)    ; REMAINDER LO -= DIVISOR LO
        SBC     4(R0)           ; SUBTRACT CARRY FROM DIVISOR HI
        SUB     16(SP),4(R0)    ; REMAINDER HI -= DIVISOR HI
        BIS     #1,2(R0)        ; SET LOW BIT IN QUOTIENT
DA3:
        DEC     R4              ; DECREMENT COUNTER
        BNE     DA2             ; IF NOT ZERO, REPEAT

        MOV     (SP)+,R4        ; RESTORE R4
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R0        ; RESTORE R0
        CLV                     ; CLEAR ERROR FLAG
        RTS     PC              ; RETURN TO CALLER

; TREE:
; ROOT NODE PTR

; NODE:
; KEY
; DATA
; LEFT PTR
; RIGHT PTR
;
; TALLOC: alloc new tree
; TPUT(TREE, KEY, DATA): insert/overwrite node
; TGET(TREE, KEY): return a ptr to a payload.
; TDEL(TREE, KEY): delete a node
; TFREE(TREE): deallocate all tree nodes
; TWALK(TREE, PROC(KEY, DATA)): visit each node


;
; TALLOC
;
; RETURN A NEW EMPTY TREE
;
TALLOC:
        MOV     #2,-(SP)        ; SIZE <- 2
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        CLR     (R0)            ; EMPTY TREE MEANS NO ROOT NODE
        RTS     PC              ; RETURN TO CALLER

;
; TGET(TREE, KEY)
;
; RETURN THE DATA VALUE FROM THE NODE WITH THE GIVEN KEY
; RETURN ZERO IF THE KEY DOES NOT APPEAR IN THE TREE
;
TGET:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     4(SP),R1        ; R1 <- ROOT

        CLR     R0              ; RETURN NULL BY DEFAULT
        TST     (R1)            ; CHECK ROOT NODE PTR
        BEQ     TGET9           ; IF NULL, RETURN
        MOV     (R1),R1         ; OTHERWISE, START AT ROOT NODE

TGET0:
        CMP     6(SP),(R1)      ; COMPARE KEY WITH ROOT.KEY
        BNE     TGET1           ; IF NOT EQUAL, SKIP AHEAD
        MOV     2(R1),R0        ; IF EQUAL, RETURN DATA
        BR      TGET9           ; WE'RE DONE
TGET1:
        BHI     TGET2           ; IF KEY > ROOT.KEY, SKIP AHEAD
        ; HERE, KEY < ROOT.KEY
        TST     4(R1)           ; CHECK ROOT.LEFT
        BEQ     TGET9           ; IF NULL, WE'RE DONE
        MOV     4(R1),R1        ; MOVE TO LEFT PTR
        BR      TGET0           ; AND TRY THERE.
TGET2:
        ; HERE, KEY > ROOT.KEY
        TST     6(R1)           ; CHECK ROOT.RIGHT
        BEQ     TGET9           ; IF NULL, WE'RE DONE
        MOV     6(R1),R1        ; MOVE TO RIGHT PTR
        BR      TGET0           ; AND TRY THERE.
TGET9:
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

;
; TPUT(TREE, KEY, DATA)
;
; PUT OR OVERWRITE THE DATA FOR THE GIVEN KEY INTO THE TREE
TPUT:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     4(SP),R1        ; R1 <- ROOT

        TST     (R1)            ; CHECK ROOT PTR
        BEQ     TPUT5           ; IF NULL, SKIP
        MOV     (R1),R1         ; START AT ROOT NODE
        BR      TPUT0           ;   AND SKIP AHEAD
TPUT5:  MOV     #10,-(SP)       ; SIZE <- 10(8)
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     6(SP),(R0)      ; NEW.KEY <- KEY
        MOV     10(SP),2(R0)    ; NEW.DATA <- DATA
        CLR     4(R0)           ; NEW.LEFT <- NULL
        CLR     6(R0)           ; NEW.RIGHT <- NULL
        MOV     R0,(R1)         ; ROOT NODE <- NEW
        BR      TPUT9           ; WE'RE DONE
TPUT0:
        CMP     6(SP),(R1)      ; COMPARE KEY WITH ROOT.KEY
        BNE     TPUT1           ; IF NOT EQUAL, SKIP
        MOV     10(SP),2(R1)    ; IF EQUAL STORE DATA IN ROOT.DATA
        BR      TPUT9           ; WE'RE DONE
TPUT1:
        BHI     TPUT2           ; IF KEY > ROOT.KEY, SKIP AHEAD
        ; HERE, KEY < ROOT.KEY.
        TST     4(R1)           ; CHECK ROOT.LEFT
        BNE     TPUT3           ; IF NOT NULL, SKIP AHEAD
        ; CREATE A NEW NODE, ASSIGN IT TO ROOT.LEFT
        MOV     #10,-(SP)       ; SIZE <- 10(8)
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     6(SP),(R0)      ; NEW.KEY <- KEY
        CLR     2(R0)           ; NEW.DATA <- 0
        CLR     4(R0)           ; NEW.LEFT <- NULL
        CLR     6(R0)           ; NEW.RIGHT <- NULL
        MOV     R0,4(R1)        ; ROOT.LEFT <- NEW
TPUT3:
        MOV     4(R1),R1        ; MOVE TO LEFT PTR
        BR      TPUT0           ; AND TRY THERE.
TPUT2:
        ; HERE, KEY > ROOT.KEY.
        TST     6(R1)           ; CHECK ROOT.RIGHT
        BNE     TPUT4           ; IF NOT NULL, SKIP AHEAD
        ; CREATE A NEW NODE, ASSIGN IT TO ROOT.LEFT
        MOV     #10,-(SP)       ; SIZE <- 10(8)
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     6(SP),(R0)      ; NEW.KEY <- KEY
        CLR     2(R0)           ; NEW.DATA <- 0
        CLR     4(R0)           ; NEW.LEFT <- NULL
        CLR     6(R0)           ; NEW.RIGHT <- NULL
        MOV     R0,6(R1)        ; ROOT.RIGHT <- NEW
TPUT4:
        MOV     6(R1),R1        ; MOVE TO RIGHT PTR
        BR      TPUT0           ; AND TRY THERE
TPUT9:
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

; DYNAMIC MEMORY ALLOCATION ROUTINES

; HEAP STRUCTURE:
;   FIRST FREE BLOCK
;   BLOCK 0:
;     SIZE
;     NEXT FREE (if deallocated)
;     DATA      (if allocated)
;   BLOCK 1:
;     SIZE
;     NEXT FREE (if deallocated)
;     DATA      (if allocated)
;   ...
;   BLOCK N:
;     SIZE
;     0         (if deallocated)
;     DATA      (if allocated)


;
; MALLOC(SIZE)
;
; ALLOCATE A CONTIGUOUS BLOCK OF MEMORY WITH AT LEAST THE GIVEN SIZE
; IN BYTES.  RETURN 0 IF THIS CANNOT BE DONE
;
MALLOC:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4

        ; WORD-ALIGN THE SIZE
        INC     12(SP)          ; INCREMENT SIZE
        BIC     #1,12(SP)       ; CLEAR LOW BIT

        ; INITIALIZE FREE BLOCK POINTER
        MOV     #HEAP,R1        ; R1 <- PTR TO FIRST FREE BLOCK

MALLO0: ; FIND A FREE BLOCK WITH ENOUGH SIZE
        MOV     R1,R2           ; R2 IS THE PREVIOUS FREE BLOCK
        TST     2(R1)           ; CHECK THE PTR
        BEQ     MALLO8          ; IF NO NEXT FREE BLOCK, RETURN NULL
        MOV     2(R1),R1        ; OTHERWISE, POINT R1 TO THE NEXT FREE
        MOV     (R1),R3         ; FIND THE DIFFERENCE BETWEEN THE
        SUB     12(SP),R3       ;   CURR BLOCK SIZE AND REQUESTED
        TST     R3              ; CHECK TO SEE IF THEY'RE EQUAL
        BEQ     MALLO1          ; IF SO, ALLOCATE WITHOUT SPLIT
        CMP     R3,#4           ; IS THE CURRENT BLOCK SIZE BIG ENOUGH
        BGT     MALLO2          ; IF SO, ALLOCATE BY SPLITTING
        BR      MALLO0          ; OTHERWISE, TRY THE NEXT FREE BLOCK

MALLO1: ; ALLOC FREE BLOCK THAT IS EXACTLY THE SAME SIZE AS REQUESTED
        MOV     2(R1),2(R2)     ; POINT THE PREV NEXT FREE TO NEXT FREE
        MOV     R1,R0           ; SET THE RESULT TO THE CURRENT BLOCK
        ADD     #2,R0           ; POINT R0 TO THE DATA ELEMENT OF BLOCK
        BR      MALLO9          ; WE'RE DONE

MALLO2: ; SPLIT FREE BLOCK
        MOV     R1,R0           ; MOVE THE BLOCK HEADER TO R0
        ADD     #2,R0           ; POINT R0 TO DATA ELEMENT OF BLOCK

        MOV     (R1),R3         ; STASH ORIGINAL BLOCK SIZE IN R3
        MOV     2(R1),R4        ; STASH ORIGINAL NEXT FREE IN R4
        MOV     12(SP),(R1)     ; WRITE NEW SIZE
        ADD     12(SP),R1       ; POINT TO START OF EMPTY PART
        ADD     #2,R1           ; ADD SPACE FOR HEADER
        SUB     12(SP),R3       ; SUBTRACT OUT NEW SIZE
        SUB     #2,R3           ; SUBCTRACT OUT HEADER SPACE
        MOV     R3,(R1)         ; SET SIZE OF EMPTY PART
        MOV     R4,2(R1)        ; SET NEXT FREE BLOCK
        MOV     R1,2(R2)        ; POINT THE PREV NEXT FREE TO EMPTY B
        BR      MALLO9          ; RETURN

MALLO8: CLR     R0              ; R0 <- NULL
MALLO9: MOV     (SP)+,R4        ; RESTORE R4
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

;
; FREE(PTR)
;
; FREE MEMORY ALLOCATED BY MALLOC
;
FREE:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3

        MOV     #HEAP,R1        ; START AT THE BEGINNING
        MOV     10(SP),R2       ; PUT DATA PTR IN R2
        SUB     #2,R2           ; POINT TO BLOCK

FREE0:
        TST     2(R1)           ; IS NEXT FREE NULL?
        BEQ     FREE9           ; IF SO, WE'RE DONE
        CMP     2(R1),R2        ; COMPARE NEXT FREE WITH PTR
        BGT     FREE1           ; IF IT'S GREATER, WE FOUND IT
        MOV     2(R1),R1        ; OTHERWISE,
        BR      FREE0           ; NEXT

FREE1:  ; MERGE WITH NEXT BLOCK IF IT IS FREE
        MOV     R2,R3           ; R3 <- PTR TO BLOCK TO FREE
        ADD     #2,R3           ; SKIP PAST HEADER
        ADD     (R2),R3         ; R3 <- PTR TO BLOCK AFTER THIS
        CMP     2(R1),R3        ; IS THE BLOCK AFTER THIS ALSO THE
                                ;   NEXT FREE BLOCK?  IF SO MERGE
        BNE     FREE2           ; IF NOT, SKIP THIS MERGE
        ADD     (R3),(R2)       ; ADD THE NEXT BLOCK'S SIZE
        ADD     #2,(R2)         ; ADD TWO TO ACCOUNT FOR HEADER
        MOV     2(R3),2(R2)     ; COPY THE NEXT BLOCK'S NEXT FREE
        MOV     R2,2(R1)        ; SET PREV BLOCK NEXT FREE TO THIS
FREE2:  ; MERGE WITH PREVIOUS BLOCK IF IT IS FREE
        MOV     R1,R3           ; R3 <- PTR TO PREV FREE BLOCK
        ADD     #2,R3           ; SKIP PAST HEADER
        ADD     (R1),R3         ; R3 <- PTR TO BLOCK AFTER PREV
        CMP     R2,R3           ; DOES THE PREV FREE BLOCK ABUT US?
        BNE     FREE3           ; IF NOT, SKIP THIS MERGE

        ADD     (R2),(R1)       ; ADD THE SIZE OF THIS BLOCK TO THE
                                ;   PREVIOUS BLOCK
        ADD     #2,(R1)         ; ADD TWO TO ACCOUNT FOR HEADER
        BR      FREE9           ; WE'RE DONE
FREE3:  ; THIS BLOCK IS BETWEEN TWO ALLOCATED BLOCKS
        MOV    2(R1),2(R2)      ; COPY NEXT PTR TO FREED BLOCK NEXT
        MOV    R2,2(R1)         ; COPY PTR TO NEXT PTR

FREE9:
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER


;
; HEAP: MEMORY SPACE FOR DYNAMIC ALLOCATION
;
HSIZE   =       100000
HEAP:   .WORD   0               ; DUMMY WORD / FAKE SIZE
        .WORD   .+2             ; FIRST FREE
        .WORD   HSIZE-6         ; BLOCK 0 SIZE
        .WORD   0               ; NEXT FREE BLOCK
        .=      .+HSIZE-10      ; MOVE ASSEMBLY POSITION PAST HEAP
