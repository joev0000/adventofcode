; ADVENT OF CODE 2019: DAY 6
; UNIVERSAL ORBIT MAP
;
; THIS PROGRAM CAN BE ASSEMBLED BY PAL-11A AND CAN BE RUN ON ANY
; PDP-11 SYSTEM WITH A HIGH-SPEED PAPER TAPE READER.
;
; INPUT:  PAPER TAPE
; OUTPUT: TTY
;
; START ADDRESS: 1000
;

;
; SET UP REGISTER AND DEVICE LABELS
;
        R0=     %0              ; REGISTER 0
        R1=     %1              ; REGISTER 1
        R2=     %2              ; REGISTER 2
        R3=     %3              ; REGISTER 3
        R4=     %4              ; REGISTER 4
        R5=     %5              ; REGISTER 5
        SP=     %6              ; STACK POINTER
        PC=     %7              ; PROGRAM COUNTER

;
; START OF PROGRAM
;
        .=      1000            ; ASSEMBLE AT ADDRESS 1000
START:  MOV     #.,SP           ; SET UP STACK

        JSR     PC,TALLOC       ; TALLOC()
        MOV     R0,R1           ; R1 <- TREE

        MOV     #40,-(SP)       ; DATA <- 40
        MOV     #400,-(SP)      ; KEY <- 400
        MOV     R1,-(SP)        ; ROOT <- R1
        JSR     PC,TPUT         ; TPUT(ROOT, KEY, DATA)
        ADD     #6,SP           ; CLEAN UP STACK

        MOV     #20,-(SP)       ; DATA <- 20
        MOV     #2000,-(SP)     ; KEY <- 2000
        MOV     R1,-(SP)        ; ROOT <- R1
        JSR     PC,TPUT         ; TPUT(ROOT, KEY, DATA)
        ADD     #6,SP           ; CLEAN UP STACK

        MOV     #400,-(SP)      ; KEY <- 400
        MOV     R1,-(SP)        ; ROOT <- R1
        JSR     PC,TGET         ; TGET(ROOT, KEY)
        ADD     #4,SP           ; CLEAN UP STACK

        HALT                    ; END OF PROGRAM
        BR      START           ; START OVER
        .EVEN

;
; STOR50(S)
;
; RETURN THE RADIX 50 VALUE OF THE FIRST THREE CHARS OF S
;
STOR50:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3

        MOV     10(SP),R2       ; R2 <- S
        MOVB    (R2)+,R3
        MOVB    R50TBL(R3),R0   ; R0 <- S[0]
        ASL     R0              ; R0 <- S[0] * 2
        ASL     R0              ; R0 <- S[0] * 4
        ASL     R0              ; R0 <- S[0] * 10
        MOV     R0,R1           ; R1 <- S[0] * 10
        ASL     R0              ; R0 <- S[0] * 20
        ASL     R0              ; R0 <- S[0] * 40
        ADD     R1,R0           ; R0 <- S[0] * 50

        MOVB    (R2)+,R3
        MOVB    R50TBL(R3),R3
        ADD     R3,R0           ; R0 <- S[0] * 50 + S[1]
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 2
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 4
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 10
        MOV     R0,R1           ; R1 <- (S[0] * 50 + S[1]) * 10
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 20
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 40
        ADD     R1,R0           ; R0 <- (S[0] * 50 + S[1]) * 50

        MOVB    (R2),R3
        MOVB    R50TBL(R3),R3
        ADD     R3,R0

        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER
;
; R50TBL: ASCII TO RAD50 TABLE
;         X =  0  1  2  3  4  5  6  7
R50TBL: .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 00X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 01X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 02X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 03X
        .BYTE  0,-1,-1,-1,33,35,-1,-1  ; 04X
        .BYTE -1,-1,-1,-1,-1,-1,34,-1  ; 05X
        .BYTE 36,37,40,41,42,43,44,45  ; 06X
        .BYTE 46,47,-1,-1,-1,-1,-1,-1  ; 07X
        .BYTE -1,01,02,03,04,05,06,07  ; 10X
        .BYTE 10,11,12,13,14,15,16,17  ; 11X
        .BYTE 20,21,22,23,24,25,26,27  ; 12X
        .BYTE 30,31,32,-1,-1,-1,-1,-1  ; 13X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 14X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 15X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 16X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 17X

; TREE:
; ROOT NODE PTR

; NODE:
; KEY
; DATA
; LEFT PTR
; RIGHT PTR
;
; TALLOC: alloc new tree
; TPUT(TREE, KEY, DATA): insert/overwrite node
; TGET(TREE, KEY): return a ptr to a payload.
; TDEL(TREE, KEY): delete a node
; TFREE(TREE): deallocate all tree nodes
; TWALK(TREE, PROC(KEY, DATA)): visit each node


;
; TALLOC
;
; RETURN A NEW EMPTY TREE
;
TALLOC:
        MOV     #2,-(SP)        ; SIZE <- 2
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        CLR     (R0)            ; EMPTY TREE MEANS NO ROOT NODE
        RTS     PC              ; RETURN TO CALLER

;
; TGET(TREE, KEY)
;
; RETURN THE DATA VALUE FROM THE NODE WITH THE GIVEN KEY
; RETURN ZERO IF THE KEY DOES NOT APPEAR IN THE TREE
;
TGET:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     4(SP),R1        ; R1 <- ROOT

        CLR     R0              ; RETURN NULL BY DEFAULT
        TST     (R1)            ; CHECK ROOT NODE PTR
        BEQ     TGET9           ; IF NULL, RETURN
        MOV     (R1),R1         ; OTHERWISE, START AT ROOT NODE

TGET0:
        CMP     6(SP),(R1)      ; COMPARE KEY WITH ROOT.KEY
        BNE     TGET1           ; IF NOT EQUAL, SKIP AHEAD
        MOV     2(R1),R0        ; IF EQUAL, RETURN DATA
        BR      TGET9           ; WE'RE DONE
TGET1:
        BGT     TGET2           ; IF KEY > ROOT.KEY, SKIP AHEAD
        ; HERE, KEY < ROOT.KEY
        TST     4(R1)           ; CHECK ROOT.LEFT
        BEQ     TGET9           ; IF NULL, WE'RE DONE
        MOV     4(R1),R1        ; MOVE TO LEFT PTR
        BR      TGET0           ; AND TRY THERE.
TGET2:
        ; HERE, KEY > ROOT.KEY
        TST     6(R1)           ; CHECK ROOT.RIGHT
        BEQ     TGET9           ; IF NULL, WE'RE DONE
        MOV     6(R1),R1        ; MOVE TO RIGHT PTR
        BR      TGET0           ; AND TRY THERE.
TGET9:
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

;
; TPUT(TREE, KEY, DATA)
;
; PUT OR OVERWRITE THE DATA FOR THE GIVEN KEY INTO THE TREE
TPUT:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     4(SP),R1        ; R1 <- ROOT

        TST     (R1)            ; CHECK ROOT PTR
        BEQ     TPUT5           ; IF NULL, SKIP
        MOV     (R1),R1         ; START AT ROOT NODE
        BR      TPUT0           ;   AND SKIP AHEAD
TPUT5:  MOV     #10,-(SP)       ; SIZE <- 10(8)
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     6(SP),(R0)      ; NEW.KEY <- KEY
        MOV     10(SP),2(R0)    ; NEW.DATA <- DATA
        CLR     4(R0)           ; NEW.LEFT <- NULL
        CLR     6(R0)           ; NEW.RIGHT <- NULL
        MOV     R0,(R1)         ; ROOT NODE <- NEW
        BR      TPUT9           ; WE'RE DONE
TPUT0:
        CMP     6(SP),(R1)      ; COMPARE KEY WITH ROOT.KEY
        BNE     TPUT1           ; IF NOT EQUAL, SKIP
        MOV     10(SP),2(R1)    ; IF EQUAL STORE DATA IN ROOT.DATA
        BR      TPUT9           ; WE'RE DONE
TPUT1:
        BGT     TPUT2           ; IF KEY > ROOT.KEY, SKIP AHEAD
        ; HERE, KEY < ROOT.KEY.
        TST     4(R1)           ; CHECK ROOT.LEFT
        BNE     TPUT3           ; IF NOT NULL, SKIP AHEAD
        ; CREATE A NEW NODE, ASSIGN IT TO ROOT.LEFT
        MOV     #10,-(SP)       ; SIZE <- 10(8)
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     6(SP),(R0)      ; NEW.KEY <- KEY
        CLR     2(R0)           ; NEW.DATA <- 0
        CLR     4(R0)           ; NEW.LEFT <- NULL
        CLR     6(R0)           ; NEW.RIGHT <- NULL
        MOV     R0,4(R1)        ; ROOT.LEFT <- NEW
TPUT3:
        MOV     4(R1),R1        ; MOVE TO LEFT PTR
        BR      TPUT0           ; AND TRY THERE.
TPUT2:
        ; HERE, KEY > ROOT.KEY.
        TST     6(R1)           ; CHECK ROOT.RIGHT
        BNE     TPUT4           ; IF NOT NULL, SKIP AHEAD
        ; CREATE A NEW NODE, ASSIGN IT TO ROOT.LEFT
        MOV     #10,-(SP)       ; SIZE <- 10(8)
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     6(SP),(R0)      ; NEW.KEY <- KEY
        CLR     2(R0)           ; NEW.DATA <- 0
        CLR     4(R0)           ; NEW.LEFT <- NULL
        CLR     6(R0)           ; NEW.RIGHT <- NULL
        MOV     R0,6(R1)        ; ROOT.RIGHT <- NEW
TPUT4:
        MOV     6(R1),R1        ; MOVE TO RIGHT PTR
        BR      TPUT0           ; AND TRY THERE
TPUT9:
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

; DYNAMIC MEMORY ALLOCATION ROUTINES

; HEAP STRUCTURE:
;   FIRST FREE BLOCK
;   BLOCK 0:
;     SIZE
;     NEXT FREE (if deallocated)
;     DATA      (if allocated)
;   BLOCK 1:
;     SIZE
;     NEXT FREE (if deallocated)
;     DATA      (if allocated)
;   ...
;   BLOCK N:
;     SIZE
;     0         (if deallocated)
;     DATA      (if allocated)


;
; MALLOC(SIZE)
;
; ALLOCATE A CONTIGUOUS BLOCK OF MEMORY WITH AT LEAST THE GIVEN SIZE
; IN BYTES.  RETURN 0 IF THIS CANNOT BE DONE
;
MALLOC:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4

        ; WORD-ALIGN THE SIZE
        INC     12(SP)          ; INCREMENT SIZE
        BIC     #1,12(SP)       ; CLEAR LOW BIT

        ; INITIALIZE FREE BLOCK POINTER
        MOV     #HEAP,R1        ; R1 <- PTR TO FIRST FREE BLOCK

MALLO0: ; FIND A FREE BLOCK WITH ENOUGH SIZE
        MOV     R1,R2           ; R2 IS THE PREVIOUS FREE BLOCK
        TST     2(R1)           ; CHECK THE PTR
        BEQ     MALLO8          ; IF NO NEXT FREE BLOCK, RETURN NULL
        MOV     2(R1),R1        ; OTHERWISE, POINT R1 TO THE NEXT FREE
        MOV     (R1),R3         ; FIND THE DIFFERENCE BETWEEN THE
        SUB     12(SP),R3       ;   CURR BLOCK SIZE AND REQUESTED
        TST     R3              ; CHECK TO SEE IF THEY'RE EQUAL
        BEQ     MALLO1          ; IF SO, ALLOCATE WITHOUT SPLIT
        CMP     R3,#4           ; IS THE CURRENT BLOCK SIZE BIG ENOUGH
        BGT     MALLO2          ; IF SO, ALLOCATE BY SPLITTING
        BR      MALLO0          ; OTHERWISE, TRY THE NEXT FREE BLOCK

MALLO1: ; ALLOC FREE BLOCK THAT IS EXACTLY THE SAME SIZE AS REQUESTED
        MOV     2(R1),2(R2)     ; POINT THE PREV NEXT FREE TO NEXT FREE
        MOV     R1,R0           ; SET THE RESULT TO THE CURRENT BLOCK
        ADD     #2,R0           ; POINT R0 TO THE DATA ELEMENT OF BLOCK
        BR      MALLO9          ; WE'RE DONE

MALLO2: ; SPLIT FREE BLOCK
        MOV     R1,R0           ; MOVE THE BLOCK HEADER TO R0
        ADD     #2,R0           ; POINT R0 TO DATA ELEMENT OF BLOCK

        MOV     (R1),R3         ; STASH ORIGINAL BLOCK SIZE IN R3
        MOV     2(R1),R4        ; STASH ORIGINAL NEXT FREE IN R4
        MOV     12(SP),(R1)     ; WRITE NEW SIZE
        ADD     12(SP),R1       ; POINT TO START OF EMPTY PART
        ADD     #2,R1           ; ADD SPACE FOR HEADER
        SUB     12(SP),R3       ; SUBTRACT OUT NEW SIZE
        SUB     #2,R3           ; SUBCTRACT OUT HEADER SPACE
        MOV     R3,(R1)         ; SET SIZE OF EMPTY PART
        MOV     R4,2(R1)        ; SET NEXT FREE BLOCK
        MOV     R1,2(R2)        ; POINT THE PREV NEXT FREE TO EMPTY B
        BR      MALLO9          ; RETURN

MALLO8: CLR     R0              ; R0 <- NULL
MALLO9: MOV     (SP)+,R4        ; RESTORE R4
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

;
; FREE(PTR)
;
; FREE MEMORY ALLOCATED BY MALLOC
;
FREE:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3

        MOV     #HEAP,R1        ; START AT THE BEGINNING
        MOV     10(SP),R2       ; PUT DATA PTR IN R2
        SUB     #2,R2           ; POINT TO BLOCK

FREE0:
        TST     2(R1)           ; IS NEXT FREE NULL?
        BEQ     FREE9           ; IF SO, WE'RE DONE
        CMP     2(R1),R2        ; COMPARE NEXT FREE WITH PTR
        BGT     FREE1           ; IF IT'S GREATER, WE FOUND IT
        MOV     2(R1),R1        ; OTHERWISE,
        BR      FREE0           ; NEXT

FREE1:  ; MERGE WITH NEXT BLOCK IF IT IS FREE
        MOV     R2,R3           ; R3 <- PTR TO BLOCK TO FREE
        ADD     #2,R3           ; SKIP PAST HEADER
        ADD     (R2),R3         ; R3 <- PTR TO BLOCK AFTER THIS
        CMP     2(R1),R3        ; IS THE BLOCK AFTER THIS ALSO THE
                                ;   NEXT FREE BLOCK?  IF SO MERGE
        BNE     FREE2           ; IF NOT, SKIP THIS MERGE
        ADD     (R3),(R2)       ; ADD THE NEXT BLOCK'S SIZE
        ADD     #2,(R2)         ; ADD TWO TO ACCOUNT FOR HEADER
        MOV     2(R3),2(R2)     ; COPY THE NEXT BLOCK'S NEXT FREE
        MOV     R2,2(R1)        ; SET PREV BLOCK NEXT FREE TO THIS
FREE2:  ; MERGE WITH PREVIOUS BLOCK IF IT IS FREE
        MOV     R1,R3           ; R3 <- PTR TO PREV FREE BLOCK
        ADD     #2,R3           ; SKIP PAST HEADER
        ADD     (R1),R3         ; R3 <- PTR TO BLOCK AFTER PREV
        CMP     R2,R3           ; DOES THE PREV FREE BLOCK ABUT US?
        BNE     FREE3           ; IF NOT, SKIP THIS MERGE

        ADD     (R2),(R1)       ; ADD THE SIZE OF THIS BLOCK TO THE
                                ;   PREVIOUS BLOCK
        ADD     #2,(R1)         ; ADD TWO TO ACCOUNT FOR HEADER
        BR      FREE9           ; WE'RE DONE
FREE3:  ; THIS BLOCK IS BETWEEN TWO ALLOCATED BLOCKS
        MOV    2(R1),2(R2)      ; COPY NEXT PTR TO FREED BLOCK NEXT
        MOV    R2,2(R1)         ; COPY PTR TO NEXT PTR

FREE9:
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER


;
; HEAP: MEMORY SPACE FOR DYNAMIC ALLOCATION
;
HSIZE   =       40000
HEAP:   .WORD   0               ; DUMMY WORD / FAKE SIZE
        .WORD   .+2             ; FIRST FREE
        .WORD   HSIZE-6         ; BLOCK 0 SIZE
        .WORD   0               ; NEXT FREE BLOCK
        .=      .+HSIZE-10      ; MOVE ASSEMBLY POSITION PAST HEAP
