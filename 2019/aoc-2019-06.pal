; ADVENT OF CODE 2019: DAY 6
; UNIVERSAL ORBIT MAP
;
; THIS PROGRAM CAN BE ASSEMBLED BY PAL-11A AND CAN BE RUN ON ANY
; PDP-11 SYSTEM WITH A HIGH-SPEED PAPER TAPE READER.
;
; INPUT:  PAPER TAPE
; OUTPUT: TTY
;
; START ADDRESS: 1000
;

;
; SET UP REGISTER AND DEVICE LABELS
;
        R0=     %0              ; REGISTER 0
        R1=     %1              ; REGISTER 1
        R2=     %2              ; REGISTER 2
        R3=     %3              ; REGISTER 3
        R4=     %4              ; REGISTER 4
        R5=     %5              ; REGISTER 5
        SP=     %6              ; STACK POINTER
        PC=     %7              ; PROGRAM COUNTER

;
; START OF PROGRAM
;
        .=      1000            ; ASSEMBLE AT ADDRESS 1000
START:  MOV     #.,SP           ; SET UP STACK

        SUB     #4,SP           ; LOCALS:
                                ; 0(SP): TREE
                                ; 2(SP): ARRAY OF ORBITS

        JSR     PC,TALLOC       ; TALLOC()
        MOV     R0,(SP)         ; TREE <- RESULT

        MOV     #17000,-(SP)    ; SIZE <- 2400(8) * 6
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     R0,2(SP)        ; ARRAY OF ORBITS <- R0
        MOV     R0,R4           ; R4 <- NEXT ELEMENT TO WRITE

        MOV     #12445,(R4)+    ; FIRST ELEMENT KEY <- R50(COM)
        CLR     (R4)+           ; FIRST ELEMENT PARENT <- NULL
        CLR     (R4)+           ; FIRST ELEMENT DISTANCE <- 0

        MOV     R0,-(SP)        ; DATA <- FIRST ELEMENT
        MOV     #12455,-(SP)    ; KEY <- R50(COM)
        MOV     4(SP),-(SP)     ; TREE <- TREE
        JSR     PC,TPUT         ; TPUT(TREE,KEY,DATA)
        ADD     #6,SP           ; CLEAN UP STACK

START1:
        JSR     PC,READPT       ; READPT()
        BCS     START2          ; IF DONE, SKIP AHEAD

        MOV     R0,(R4)         ; KEY <- CHLID KEY
        MOV     R1,2(R4)        ; PARENT <- PARENT KEY
        MOV     #-1,4(R4)       ; DISTANCE TO COM <- -1

        MOV     R4,-(SP)        ; DATA <- ELEMENT
        MOV     R0,-(SP)        ; KEY <- CHILD KEY
        MOV     4(SP),-(SP)     ; TREE <- TREE
        JSR     PC,TPUT         ; TPUT(TREE,KEY,DATA)
        ADD     #6,SP           ; CLEAN UP STACK

        ADD     #6,R4           ; MOVE TO NEXT ELEMENT
        BR      START1          ; NEXT LINE
START2:
        CLR     (R4)            ; LAST ELEMENT KEY <- 0

        MOV     2(SP),R4        ; START AT THE BEGINNING
        CLR     R2              ; CLEAR COUNT(LO)
        CLR     R3              ; CLEAR COUNT(HI)
START3:
        TST     (R4)            ; CHECK THE ELEMENT KEY
        BEQ     START4          ; IF NULL, SKIP OUT OF LOOP

        MOV     (SP),-(SP)      ; TREE <- TREE
        MOV     R4,-(SP)        ; ELEMENT <- ELEMENT
        JSR     PC,DIST         ; DIST(ELEMENT,TREE)
        ADD     #4,SP           ; CLEAN UP STACK
        ADD     R0,R2           ; ADD DISTANCE TO THE COUNT
        ADC     R3              ; ADD CARRY

        ADD     #6,R4           ; POINT TO NEXT ELEMENT
        BR      START3          ; NEXT ELEMENT
START4:
        MOV     R2,-(SP)        ; ARG1 <- R2
        MOV     R3,-(SP)        ; ARG0 <- R3
        MOV     #PART1,-(SP)    ; FORMAT <- PART1
        MOV     #STDOUT,-(SP)   ; STREAM < STDOUT
        JSR     PC,FPRNTF       ; FPRNTF(STREAM,FORMAT,...)
        ADD     #10,SP          ; CLEAN UP STACK

START9:
        ADD     #4,SP           ; CLEAN UP LOCALS
        HALT                    ; END OF PROGRAM
        JMP     START           ; START OVER

PART1:  .ASCII /PART 1: %lu/
        .BYTE  15,12,0
        .EVEN
;
; DIST(ELEMENT, TREE)
;
; FIND THE DISTANCE OF THE ELEMENT TO COM
;
DIST:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4
        MOV     R5,-(SP)        ; SAVE R5
        MOV     14(SP),R1       ; R1 <- ELEMENT
        MOV     16(SP),R2       ; R2 <- TREE
        CLR     R3              ; R3 <- STACK DEPTH (0)
        MOV     #4000,-(SP)     ; SIZE <- 4000(8)
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     R0,R4           ; R4 <- ELEMENT STACK
        MOV     #4000,R5        ; R5 <- ELEMENT STACK POINTER
        ADD     R4,R5           ;

DIST1:
        MOV     4(R1),R0        ; CHECK THE DISTANCE
        BPL     DIST8           ; IF IT'S POSITIVE, WE'RE DONE
        MOV     R1,-(R5)        ; PUSH THIS ELEMENT
        INC     R3              ; INCREMENT STACK DEPTH
        MOV     2(R1),-(SP)     ; KEY <- PARENT
        MOV     R2,-(SP)        ; TREE <- TREE
        JSR     PC,TGET         ; TGET(TREE,KEY)
        ADD     #4,SP           ; CLEAN UP STACK
        MOV     R0,R1           ; THIS IS OUR NEW ELEMENT
        BR      DIST1           ; CHECK THE DISTANCE

DIST8:
        TST     R3              ; CHECK STACK DEPTH
        BEQ     DIST9           ; IF ZERO, WE'RE DONE
        INC     R0              ; INCREMENT THE DISTANCE
        DEC     R3              ; DECREMENT THE STACK DEPTH
        MOV     (R5)+,R1        ; POP AN ELEMENT
        MOV     R0,4(R1)        ; SET ITS DISTANCE
        BR      DIST8           ; CHECK THE NEXT ELEMENT ON THE STACK
DIST9:
        MOV     R4,-(SP)        ; BLOCK <- R4
        JSR     PC,FREE         ; FREE(BLOCK)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     (SP)+,R5        ; RESTORE R5
        MOV     (SP)+,R4        ; RESTORE R4
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

;
; READPT(): R0: ORBITER, R1: ORBITEE
;
; READ A LINE FROM PAPER TAPE
; SET CARRY ON ERROR
;
READPT:
        MOV     R2,-(SP)        ; STASH R2
        SUB     #4,SP           ; LOCALS
                                ; 0: BUFFER

        MOV     SP,R2           ; R2 <- BUFFER
        MOV     #4,-(SP)        ; NBYTE <- 4
        MOV     R2,-(SP)        ; BUF <- BUFFER
        MOV     #3,-(SP)        ; FILEDES <- 3 (PTIN)
        JSR     PC,READ         ; READ(FILEDES, BUF, NBYTE)
        CMP     #4,R0           ; DID WE READ FOUR BYTES?
        BNE     READP7          ; NO, BAIL OUT
        MOV     R2,-(SP)        ; S <- BUFFER
        JSR     PC,STOR50       ; STOR50(S)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     R0,R1           ; SAVE ORBITEE

        JSR     PC,READ         ; READ(FILEDES, BUF, NBYTE)
        CMP     #4,R0           ; DID WE READ FOUR BYTES?
        BNE     READP7          ; NO, BAIL OUT
        ADD     #6,SP           ; CLEAN UP STACK
        MOV     R2,-(SP)        ; S <- BUFFER
        JSR     PC,STOR50       ; STOR50(S)
        TST     (SP)+           ; CLEAN UP STACK
        BR      READP8          ; SKIP TO THE END
READP7:
        ADD     #12,SP          ; CLEAN UP STACK FROM READ AND LOCALS
        SEC                     ; SET CARRY (ERROR)
        BR      READP9          ; WE'RE DONE

READP8: ADD     #4,SP           ; DEALLOCATE LOCALS
        CLC                     ; CLEAR CARRY (NO ERROR)
READP9: MOV     (SP)+,R2        ; RESTORE R2
        RTS     PC              ; RETURN TO CALLER

;
; STOR50(S)
;
; RETURN THE RADIX 50 VALUE OF THE FIRST THREE CHARS OF S
;
STOR50:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3

        MOV     10(SP),R2       ; R2 <- S
        MOVB    (R2)+,R3
        MOVB    R50TBL(R3),R0   ; R0 <- S[0]
        ASL     R0              ; R0 <- S[0] * 2
        ASL     R0              ; R0 <- S[0] * 4
        ASL     R0              ; R0 <- S[0] * 10
        MOV     R0,R1           ; R1 <- S[0] * 10
        ASL     R0              ; R0 <- S[0] * 20
        ASL     R0              ; R0 <- S[0] * 40
        ADD     R1,R0           ; R0 <- S[0] * 50

        MOVB    (R2)+,R3
        MOVB    R50TBL(R3),R3
        ADD     R3,R0           ; R0 <- S[0] * 50 + S[1]
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 2
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 4
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 10
        MOV     R0,R1           ; R1 <- (S[0] * 50 + S[1]) * 10
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 20
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 40
        ADD     R1,R0           ; R0 <- (S[0] * 50 + S[1]) * 50

        MOVB    (R2),R3
        MOVB    R50TBL(R3),R3
        ADD     R3,R0

        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER
;
; R50TBL: ASCII TO RAD50 TABLE
;         X =  0  1  2  3  4  5  6  7
R50TBL: .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 00X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 01X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 02X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 03X
        .BYTE  0,-1,-1,-1,33,35,-1,-1  ; 04X
        .BYTE -1,-1,-1,-1,-1,-1,34,-1  ; 05X
        .BYTE 36,37,40,41,42,43,44,45  ; 06X
        .BYTE 46,47,-1,-1,-1,-1,-1,-1  ; 07X
        .BYTE -1,01,02,03,04,05,06,07  ; 10X
        .BYTE 10,11,12,13,14,15,16,17  ; 11X
        .BYTE 20,21,22,23,24,25,26,27  ; 12X
        .BYTE 30,31,32,-1,-1,-1,-1,-1  ; 13X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 14X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 15X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 16X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 17X

; TREE:
; ROOT NODE PTR

; NODE:
; KEY
; DATA
; LEFT PTR
; RIGHT PTR
;
; TALLOC: alloc new tree
; TPUT(TREE, KEY, DATA): insert/overwrite node
; TGET(TREE, KEY): return a ptr to a payload.
; TDEL(TREE, KEY): delete a node
; TFREE(TREE): deallocate all tree nodes
; TWALK(TREE, PROC(KEY, DATA)): visit each node


;
; TALLOC
;
; RETURN A NEW EMPTY TREE
;
TALLOC:
        MOV     #2,-(SP)        ; SIZE <- 2
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        CLR     (R0)            ; EMPTY TREE MEANS NO ROOT NODE
        RTS     PC              ; RETURN TO CALLER

;
; TGET(TREE, KEY)
;
; RETURN THE DATA VALUE FROM THE NODE WITH THE GIVEN KEY
; RETURN ZERO IF THE KEY DOES NOT APPEAR IN THE TREE
;
TGET:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     4(SP),R1        ; R1 <- ROOT

        CLR     R0              ; RETURN NULL BY DEFAULT
        TST     (R1)            ; CHECK ROOT NODE PTR
        BEQ     TGET9           ; IF NULL, RETURN
        MOV     (R1),R1         ; OTHERWISE, START AT ROOT NODE

TGET0:
        CMP     6(SP),(R1)      ; COMPARE KEY WITH ROOT.KEY
        BNE     TGET1           ; IF NOT EQUAL, SKIP AHEAD
        MOV     2(R1),R0        ; IF EQUAL, RETURN DATA
        BR      TGET9           ; WE'RE DONE
TGET1:
        BHI     TGET2           ; IF KEY > ROOT.KEY, SKIP AHEAD
        ; HERE, KEY < ROOT.KEY
        TST     4(R1)           ; CHECK ROOT.LEFT
        BEQ     TGET9           ; IF NULL, WE'RE DONE
        MOV     4(R1),R1        ; MOVE TO LEFT PTR
        BR      TGET0           ; AND TRY THERE.
TGET2:
        ; HERE, KEY > ROOT.KEY
        TST     6(R1)           ; CHECK ROOT.RIGHT
        BEQ     TGET9           ; IF NULL, WE'RE DONE
        MOV     6(R1),R1        ; MOVE TO RIGHT PTR
        BR      TGET0           ; AND TRY THERE.
TGET9:
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

;
; TPUT(TREE, KEY, DATA)
;
; PUT OR OVERWRITE THE DATA FOR THE GIVEN KEY INTO THE TREE
TPUT:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     4(SP),R1        ; R1 <- ROOT

        TST     (R1)            ; CHECK ROOT PTR
        BEQ     TPUT5           ; IF NULL, SKIP
        MOV     (R1),R1         ; START AT ROOT NODE
        BR      TPUT0           ;   AND SKIP AHEAD
TPUT5:  MOV     #10,-(SP)       ; SIZE <- 10(8)
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     6(SP),(R0)      ; NEW.KEY <- KEY
        MOV     10(SP),2(R0)    ; NEW.DATA <- DATA
        CLR     4(R0)           ; NEW.LEFT <- NULL
        CLR     6(R0)           ; NEW.RIGHT <- NULL
        MOV     R0,(R1)         ; ROOT NODE <- NEW
        BR      TPUT9           ; WE'RE DONE
TPUT0:
        CMP     6(SP),(R1)      ; COMPARE KEY WITH ROOT.KEY
        BNE     TPUT1           ; IF NOT EQUAL, SKIP
        MOV     10(SP),2(R1)    ; IF EQUAL STORE DATA IN ROOT.DATA
        BR      TPUT9           ; WE'RE DONE
TPUT1:
        BHI     TPUT2           ; IF KEY > ROOT.KEY, SKIP AHEAD
        ; HERE, KEY < ROOT.KEY.
        TST     4(R1)           ; CHECK ROOT.LEFT
        BNE     TPUT3           ; IF NOT NULL, SKIP AHEAD
        ; CREATE A NEW NODE, ASSIGN IT TO ROOT.LEFT
        MOV     #10,-(SP)       ; SIZE <- 10(8)
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     6(SP),(R0)      ; NEW.KEY <- KEY
        CLR     2(R0)           ; NEW.DATA <- 0
        CLR     4(R0)           ; NEW.LEFT <- NULL
        CLR     6(R0)           ; NEW.RIGHT <- NULL
        MOV     R0,4(R1)        ; ROOT.LEFT <- NEW
TPUT3:
        MOV     4(R1),R1        ; MOVE TO LEFT PTR
        BR      TPUT0           ; AND TRY THERE.
TPUT2:
        ; HERE, KEY > ROOT.KEY.
        TST     6(R1)           ; CHECK ROOT.RIGHT
        BNE     TPUT4           ; IF NOT NULL, SKIP AHEAD
        ; CREATE A NEW NODE, ASSIGN IT TO ROOT.LEFT
        MOV     #10,-(SP)       ; SIZE <- 10(8)
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK
        MOV     6(SP),(R0)      ; NEW.KEY <- KEY
        CLR     2(R0)           ; NEW.DATA <- 0
        CLR     4(R0)           ; NEW.LEFT <- NULL
        CLR     6(R0)           ; NEW.RIGHT <- NULL
        MOV     R0,6(R1)        ; ROOT.RIGHT <- NEW
TPUT4:
        MOV     6(R1),R1        ; MOVE TO RIGHT PTR
        BR      TPUT0           ; AND TRY THERE
TPUT9:
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

; DYNAMIC MEMORY ALLOCATION ROUTINES

; HEAP STRUCTURE:
;   FIRST FREE BLOCK
;   BLOCK 0:
;     SIZE
;     NEXT FREE (if deallocated)
;     DATA      (if allocated)
;   BLOCK 1:
;     SIZE
;     NEXT FREE (if deallocated)
;     DATA      (if allocated)
;   ...
;   BLOCK N:
;     SIZE
;     0         (if deallocated)
;     DATA      (if allocated)


;
; MALLOC(SIZE)
;
; ALLOCATE A CONTIGUOUS BLOCK OF MEMORY WITH AT LEAST THE GIVEN SIZE
; IN BYTES.  RETURN 0 IF THIS CANNOT BE DONE
;
MALLOC:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4

        ; WORD-ALIGN THE SIZE
        INC     12(SP)          ; INCREMENT SIZE
        BIC     #1,12(SP)       ; CLEAR LOW BIT

        ; INITIALIZE FREE BLOCK POINTER
        MOV     #HEAP,R1        ; R1 <- PTR TO FIRST FREE BLOCK

MALLO0: ; FIND A FREE BLOCK WITH ENOUGH SIZE
        MOV     R1,R2           ; R2 IS THE PREVIOUS FREE BLOCK
        TST     2(R1)           ; CHECK THE PTR
        BEQ     MALLO8          ; IF NO NEXT FREE BLOCK, RETURN NULL
        MOV     2(R1),R1        ; OTHERWISE, POINT R1 TO THE NEXT FREE
        MOV     (R1),R3         ; FIND THE DIFFERENCE BETWEEN THE
        SUB     12(SP),R3       ;   CURR BLOCK SIZE AND REQUESTED
        TST     R3              ; CHECK TO SEE IF THEY'RE EQUAL
        BEQ     MALLO1          ; IF SO, ALLOCATE WITHOUT SPLIT
        CMP     R3,#4           ; IS THE CURRENT BLOCK SIZE BIG ENOUGH
        BGT     MALLO2          ; IF SO, ALLOCATE BY SPLITTING
        BR      MALLO0          ; OTHERWISE, TRY THE NEXT FREE BLOCK

MALLO1: ; ALLOC FREE BLOCK THAT IS EXACTLY THE SAME SIZE AS REQUESTED
        MOV     2(R1),2(R2)     ; POINT THE PREV NEXT FREE TO NEXT FREE
        MOV     R1,R0           ; SET THE RESULT TO THE CURRENT BLOCK
        ADD     #2,R0           ; POINT R0 TO THE DATA ELEMENT OF BLOCK
        BR      MALLO9          ; WE'RE DONE

MALLO2: ; SPLIT FREE BLOCK
        MOV     R1,R0           ; MOVE THE BLOCK HEADER TO R0
        ADD     #2,R0           ; POINT R0 TO DATA ELEMENT OF BLOCK

        MOV     (R1),R3         ; STASH ORIGINAL BLOCK SIZE IN R3
        MOV     2(R1),R4        ; STASH ORIGINAL NEXT FREE IN R4
        MOV     12(SP),(R1)     ; WRITE NEW SIZE
        ADD     12(SP),R1       ; POINT TO START OF EMPTY PART
        ADD     #2,R1           ; ADD SPACE FOR HEADER
        SUB     12(SP),R3       ; SUBTRACT OUT NEW SIZE
        SUB     #2,R3           ; SUBCTRACT OUT HEADER SPACE
        MOV     R3,(R1)         ; SET SIZE OF EMPTY PART
        MOV     R4,2(R1)        ; SET NEXT FREE BLOCK
        MOV     R1,2(R2)        ; POINT THE PREV NEXT FREE TO EMPTY B
        BR      MALLO9          ; RETURN

MALLO8: CLR     R0              ; R0 <- NULL
MALLO9: MOV     (SP)+,R4        ; RESTORE R4
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

;
; FREE(PTR)
;
; FREE MEMORY ALLOCATED BY MALLOC
;
FREE:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3

        MOV     #HEAP,R1        ; START AT THE BEGINNING
        MOV     10(SP),R2       ; PUT DATA PTR IN R2
        SUB     #2,R2           ; POINT TO BLOCK

FREE0:
        TST     2(R1)           ; IS NEXT FREE NULL?
        BEQ     FREE9           ; IF SO, WE'RE DONE
        CMP     2(R1),R2        ; COMPARE NEXT FREE WITH PTR
        BGT     FREE1           ; IF IT'S GREATER, WE FOUND IT
        MOV     2(R1),R1        ; OTHERWISE,
        BR      FREE0           ; NEXT

FREE1:  ; MERGE WITH NEXT BLOCK IF IT IS FREE
        MOV     R2,R3           ; R3 <- PTR TO BLOCK TO FREE
        ADD     #2,R3           ; SKIP PAST HEADER
        ADD     (R2),R3         ; R3 <- PTR TO BLOCK AFTER THIS
        CMP     2(R1),R3        ; IS THE BLOCK AFTER THIS ALSO THE
                                ;   NEXT FREE BLOCK?  IF SO MERGE
        BNE     FREE2           ; IF NOT, SKIP THIS MERGE
        ADD     (R3),(R2)       ; ADD THE NEXT BLOCK'S SIZE
        ADD     #2,(R2)         ; ADD TWO TO ACCOUNT FOR HEADER
        MOV     2(R3),2(R2)     ; COPY THE NEXT BLOCK'S NEXT FREE
        MOV     R2,2(R1)        ; SET PREV BLOCK NEXT FREE TO THIS
FREE2:  ; MERGE WITH PREVIOUS BLOCK IF IT IS FREE
        MOV     R1,R3           ; R3 <- PTR TO PREV FREE BLOCK
        ADD     #2,R3           ; SKIP PAST HEADER
        ADD     (R1),R3         ; R3 <- PTR TO BLOCK AFTER PREV
        CMP     R2,R3           ; DOES THE PREV FREE BLOCK ABUT US?
        BNE     FREE3           ; IF NOT, SKIP THIS MERGE

        ADD     (R2),(R1)       ; ADD THE SIZE OF THIS BLOCK TO THE
                                ;   PREVIOUS BLOCK
        ADD     #2,(R1)         ; ADD TWO TO ACCOUNT FOR HEADER
        BR      FREE9           ; WE'RE DONE
FREE3:  ; THIS BLOCK IS BETWEEN TWO ALLOCATED BLOCKS
        MOV    2(R1),2(R2)      ; COPY NEXT PTR TO FREED BLOCK NEXT
        MOV    R2,2(R1)         ; COPY PTR TO NEXT PTR

FREE9:
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER


;
; HEAP: MEMORY SPACE FOR DYNAMIC ALLOCATION
;
HSIZE   =       100000
HEAP:   .WORD   0               ; DUMMY WORD / FAKE SIZE
        .WORD   .+2             ; FIRST FREE
        .WORD   HSIZE-6         ; BLOCK 0 SIZE
        .WORD   0               ; NEXT FREE BLOCK
        .=      .+HSIZE-10      ; MOVE ASSEMBLY POSITION PAST HEAP
