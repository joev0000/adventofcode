; ADVENT OF CODE 2019: DAY 6
; UNIVERSAL ORBIT MAP
;
; THIS PROGRAM CAN BE ASSEMBLED BY PAL-11A AND CAN BE RUN ON ANY
; PDP-11 SYSTEM WITH A HIGH-SPEED PAPER TAPE READER.
;
; INPUT:  PAPER TAPE
; OUTPUT: TTY
;
; START ADDRESS: 1000
;

;
; SET UP REGISTER AND DEVICE LABELS
;
        R0=     %0              ; REGISTER 0
        R1=     %1              ; REGISTER 1
        R2=     %2              ; REGISTER 2
        R3=     %3              ; REGISTER 3
        R4=     %4              ; REGISTER 4
        R5=     %5              ; REGISTER 5
        SP=     %6              ; STACK POINTER
        PC=     %7              ; PROGRAM COUNTER

;
; START OF PROGRAM
;
        .=      1000            ; ASSEMBLE AT ADDRESS 1000
START:  MOV     #.,SP           ; SET UP STACK

        MOV     #10,-(SP)       ; SIZE <- 20
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK

        MOV     R0,R1

        MOV     #20,-(SP)       ; SIZE <- 14
        JSR     PC,MALLOC       ; MALLOC(SIZE)
        TST     (SP)+           ; CLEAN UP STACK

        MOV     R0,R2

        MOV     R1,-(SP)        ; PTR <- R1
        JSR     PC,FREE         ; FREE(PTR)
        TST     (SP)+           ; CLEAN UP STACK

        MOV     R2,-(SP)        ; PTR <- R1
        JSR     PC,FREE         ; FREE(PTR)
        TST     (SP)+           ; CLEAN UP STACK

        HALT                    ; END OF PROGRAM
        BR      START           ; START OVER
        .EVEN

;
; STOR50(S)
;
; RETURN THE RADIX 50 VALUE OF THE FIRST THREE CHARS OF S
;
STOR50:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3

        MOV     10(SP),R2       ; R2 <- S
        MOVB    (R2)+,R3
        MOVB    R50TBL(R3),R0   ; R0 <- S[0]
        ASL     R0              ; R0 <- S[0] * 2
        ASL     R0              ; R0 <- S[0] * 4
        ASL     R0              ; R0 <- S[0] * 10
        MOV     R0,R1           ; R1 <- S[0] * 10
        ASL     R0              ; R0 <- S[0] * 20
        ASL     R0              ; R0 <- S[0] * 40
        ADD     R1,R0           ; R0 <- S[0] * 50

        MOVB    (R2)+,R3
        MOVB    R50TBL(R3),R3
        ADD     R3,R0           ; R0 <- S[0] * 50 + S[1]
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 2
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 4
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 10
        MOV     R0,R1           ; R1 <- (S[0] * 50 + S[1]) * 10
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 20
        ASL     R0              ; R0 <- (S[0] * 50 + S[1]) * 40
        ADD     R1,R0           ; R0 <- (S[0] * 50 + S[1]) * 50

        MOVB    (R2),R3
        MOVB    R50TBL(R3),R3
        ADD     R3,R0

        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER
;
; R50TBL: ASCII TO RAD50 TABLE
;         X =  0  1  2  3  4  5  6  7
R50TBL: .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 00X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 01X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 02X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 03X
        .BYTE  0,-1,-1,-1,33,35,-1,-1  ; 04X
        .BYTE -1,-1,-1,-1,-1,-1,34,-1  ; 05X
        .BYTE 36,37,40,41,42,43,44,45  ; 06X
        .BYTE 46,47,-1,-1,-1,-1,-1,-1  ; 07X
        .BYTE -1,01,02,03,04,05,06,07  ; 10X
        .BYTE 10,11,12,13,14,15,16,17  ; 11X
        .BYTE 20,21,22,23,24,25,26,27  ; 12X
        .BYTE 30,31,32,-1,-1,-1,-1,-1  ; 13X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 14X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 15X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 16X
        .BYTE -1,-1,-1,-1,-1,-1,-1,-1  ; 17X

; TREE
;
; KEY
; DATA
; LEFT PTR
; RIGHT PTR
;
; TINIT(TREE): initalize table at PTR.
; TPUT(TREE, KEY, DATA): insert/overwrite node
; TGET(TREE, KEY): return a ptr to a payload.
; TWALK(TREE, PROC(KEY, DATA)): visit each node
;
; TREE:
;   NEXT FREE
;   ROOT PTR

; DYNAMIC MEMORY ALLOCATION ROUTINES

; HEAP STRUCTURE:
;   FIRST FREE BLOCK
;   BLOCK 0:
;     SIZE
;     NEXT FREE (if deallocated)
;     DATA      (if allocated)
;   BLOCK 1:
;     SIZE
;     NEXT FREE (if deallocated)
;     DATA      (if allocated)
;   ...
;   BLOCK N:
;     SIZE
;     0         (if deallocated)
;     DATA      (if allocated)


;
; MALLOC(SIZE)
;
; ALLOCATE A CONTIGUOUS BLOCK OF MEMORY WITH AT LEAST THE GIVEN SIZE
; IN BYTES.  RETURN 0 IF THIS CANNOT BE DONE
;
MALLOC:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4

        ; WORD-ALIGN THE SIZE
        INC     12(SP)          ; INCREMENT SIZE
        BIC     #1,12(SP)       ; CLEAR LOW BIT

        ; INITIALIZE FREE BLOCK POINTER
        MOV     #HEAP,R1        ; R1 <- PTR TO FIRST FREE BLOCK
        SUB     #2,R1           ; SUBTRACT TWO, TO SIMULATE THE
                                ;   FREE BLOCK FIELD, IN OFFSET 2

MALLO0: ; FIND A FREE BLOCK WITH ENOUGH SIZE
        MOV     R1,R2           ; R2 IS THE PREVIOUS FREE BLOCK
        TST     2(R1)           ; CHECK THE PTR
        BEQ     MALLO8          ; IF NO NEXT FREE BLOCK, RETURN NULL
        MOV     2(R1),R1        ; OTHERWISE, POINT R1 TO THE NEXT FREE
        MOV     (R1),R3         ; FIND THE DIFFERENCE BETWEEN THE
        SUB     12(SP),R3       ;   CURR BLOCK SIZE AND REQUESTED
        TST     R3              ; CHECK TO SEE IF THEY'RE EQUAL
        BEQ     MALLO1          ; IF SO, ALLOCATE WITHOUT SPLIT
        CMP     R3,#4           ; IS THE CURRENT BLOCK SIZE BIG ENOUGH
        BGT     MALLO2          ; IF SO, ALLOCATE BY SPLITTING
        BR      MALLO0          ; OTHERWISE, TRY THE NEXT FREE BLOCK

MALLO1: ; ALLOC FREE BLOCK THAT IS EXACTLY THE SAME SIZE AS REQUESTED
        MOV     2(R1),2(R2)     ; POINT THE PREV NEXT FREE TO NEXT FREE
        MOV     R1,R0           ; SET THE RESULT TO THE CURRENT BLOCK
        ADD     #2,R0           ; POINT R0 TO THE DATA ELEMENT OF BLOCK
        BR      MALLO9          ; WE'RE DONE

MALLO2: ; SPLIT FREE BLOCK
        MOV     R1,R0           ; MOVE THE BLOCK HEADER TO R0
        ADD     #2,R0           ; POINT R0 TO DATA ELEMENT OF BLOCK

        MOV     (R1),R3         ; STASH ORIGINAL BLOCK SIZE IN R3
        MOV     2(R1),R4        ; STASH ORIGINAL NEXT FREE IN R4
        MOV     12(SP),(R1)     ; WRITE NEW SIZE
        ADD     12(SP),R1       ; POINT TO START OF EMPTY PART
        ADD     #2,R1           ; ADD SPACE FOR HEADER
        SUB     12(SP),R3       ; SUBTRACT OUT NEW SIZE
        SUB     #2,R3           ; SUBCTRACT OUT HEADER SPACE
        MOV     R3,(R1)         ; SET SIZE OF EMPTY PART
        MOV     R4,2(R1)        ; SET NEXT FREE BLOCK
        MOV     R1,2(R2)        ; POINT THE PREV NEXT FREE TO EMPTY B
        BR      MALLO9          ; RETURN

MALLO8: CLR     R0              ; R0 <- NULL
MALLO9: MOV     (SP)+,R4        ; RESTORE R4
        MOV     (SP)+,R3        ; RESTORE R3
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER

;
; FREE(PTR)
;
; FREE MEMORY ALLOCATED BY MALLOC
;
FREE:
        MOV     R1,-(SP)        ; SAVE R1
        MOV     R2,-(SP)        ; SAVE R2

        MOV     #HEAP,R1        ; START AT THE BEGINNIG
        SUB     #2,R1           ; ADJUSTMENT TO FIND NEXT FREE PTR
        MOV     6(SP),R2        ; PUT PTR IN R2

FREE0:
        TST     2(R1)           ; IS NEXT FREE NULL?
        BEQ     FREE9           ; IF SO, WE'RE DONE
        CMP     2(R1),R2        ; COMPARE NEXT FREE WITH PTR
        BGT     FREE1           ; IF IT'S GREATER, WE FOUND IT
        MOV     2(R1),R1        ; OTHERWISE,
        BR      FREE0           ; NEXT

FREE1:
        MOV    2(R1),(R2)       ; COPY NEXT PTR TO FREED BLOCK NEXT
        SUB    #2,R2            ; SET R2 TO FREED BLOCK
        MOV    R2,2(R1)         ; COPY PTR TO NEXT PTR

FREE9:
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     (SP)+,R1        ; RESTORE R1
        RTS     PC              ; RETURN TO CALLER


;
; HEAP: MEMORY SPACE FOR DYNAMIC ALLOCATION
;
HSIZE   =       40000
HEAP:   .WORD   .+2             ; FIRST FREE
        .WORD   HSIZE-4         ; BLOCK 0 SIZE
        .WORD   0               ; NEXT FREE BLOCK
        .=      .+HSIZE-6       ; MOVE ASSEMBLY POSITION PAST HEAP
