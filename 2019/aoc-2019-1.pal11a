; ADVENT OF CODE 2019: DAY 1
; THE TYRANNY OF THE ROCKET EQUATION
;
; THIS PROGRAM CAN BE ASSEMBLED BY PAL-11A AND CAN BE RUN ON ANY
; PDP-11 SYSTEM WITH A HIGH-SPEED PAPER TAPE READER.
;
; INPUT:  PAPER TAPE
; OUTPUT: TTY
;
; START ADDRESS: 1000
;

;
; SET UP REGISTER AND DEVICE LABELS
;
        R0=     %0              ; REGISTER 0
        R1=     %1              ; REGISTER 1
        R2=     %2              ; REGISTER 2
        R3=     %3              ; REGISTER 3
        R4=     %4              ; REGISTER 4
        R5=     %5              ; REGISTER 5
        SP=     %6              ; STACK POINTER
        PC=     %7              ; PROGRAM COUNTER
        TPS=    177564          ; TELEPRINTER STATUS WORD
        TPB=    177566          ; TELEPRINTER BUFFER

;
; START OF PROGRAM
;
        .=      1000            ; ASSEMBLE AT ADDRESS 1000
START:  MOV     #.,SP           ; SET UP STACK

        MOV     #MSG,-(SP)      ; PUSH MESSAGE POINTER
        JSR     PC,PUTS         ; PUTS(MESSAGE)
        TST     (SP)+           ; CLEAN UP STACK

        MOV     #3,-(SP)        ; PUSH 3D
        MOV     #3661,-(SP)     ; PUSH 1969D
        JSR     PC,DIVU16       ; DIVU16(3661, 3)
        ADD     #4,SP           ; CLEAN UP STACK
        SUB     #2,R0           ; SUBTRACT 2

        MOV     #PUTC,-(SP)     ; PUSH PUTC SUBROUTINE
        MOV     R0,-(SP)        ; PUSH VALUE
        JSR     PC,FU1610       ; FU1610(VALUE, PUTC)
        ADD     #4,SP           ; CLEAN UP STACK

        MOV     #CRLF,-(SP)     ; PUSH CRLF POINTER
        JSR     PC,PUTS         ; PUTS(CRLF)
        TST     (SP)+           ; CLEAN UP STACK

        HALT                    ; PROGRAM COMPLETE
        BR      START           ; RESTART ON CONTINUE

MSG:    .ASCII  /ADVENT OF CODE 2019 DAY 1/
CRLF:   .BYTE   15,12,0         ; CR,LF

;
; LIBRARY CODE
;
; TODO: THIS CAN MOVE TO ITS OWN MODULE WHEN WE START TO USE PAL-11S
;       FOR NOW, IT IS COPIED INTO EACH PROGRAM
;

        .EVEN
;
; PUTC(CHAR)
;
; WRITE A CHARACTER TO TELEPRINTER USING PROGRAMMED I/O
;
PUTC:   MOV     2(SP),R0        ; R0 <- CHAR
PC1:    TSTB    TPS             ; IS THE TTY READY?
        BPL     PC1             ; IF NOT, TRY AGAIN
        MOVB    R0,TPB          ; WRITE BYTE TO TTY, INC PTR
        RTS     PC              ; RETURN TO CALLER


;
; PUTS(BUFFER)
;
; WRITE NULL-TERMINATED STRING TO TELEPRINTER
; USING PROGRAMMED I/O
;
PUTS:   MOV     2(SP),R0        ; R0 <- BUFFER
PS0:    TSTB    @R0             ; IS THE BYTE ZERO?
        BEQ     PS2             ; YES, DONE
PS1:    TSTB    TPS             ; IS THE TTY READY?
        BPL     PS1             ; IF NOT, TRY AGAIN
        MOVB    (R0)+,TPB       ; WRITE BYTE TO TTY, INC PTR
        BR      PS0             ; CONTINUE
PS2:    RTS     PC              ; RETURN TO CALLER

;
; FU1610(VALUE, OUT)
;
; FORAMT AN UNSIGNED WORD TO DECIMAL, CALLING THE OUT SUBROUTINE
; FOR EACH DIGIT.
;
FU1610:  MOV    R2,-(SP)        ; SAVE R2
         MOV    R3,-(SP)        ; SAVE R3
         MOV    R4,-(SP)        ; SAVE R4
         MOV    10(SP),R0       ; R0 <- VALUE
         MOV    12(SP),R3       ; R3 <- OUT SUBROUTINE
         CLR    R4              ; R4 <- COUNTER (0)

F1:      MOV    #12,-(SP)       ; PUSH DIVISOR (10D)
         MOV    R0,-(SP)        ; PUSH DIVIDEND (VALUE)
         JSR    PC,DIVU16       ; DIVU16(VALUE, 10D)
         ADD    #4,SP           ; CLEAN UP STACK
         ADD    #60,R1          ; CONVERT REMAINDER TO CHAR
         MOVB   R1,-(SP)        ; PUSH DIGIT TO STACK
         INC    R4              ; INCREMENT THE COUNTER
         TST    R0              ; CHECK THE QUOTIENT
         BNE    F1              ; IF NOT ZERO, MOVE TO NEXT DIGIT

F2:      JSR    PC,(R3)         ; OUT(CHAR) CHAR ALREADY ON STACK
         TSTB   (SP)+           ; POP CHAR TO NOWHERE
         DEC    R4              ; DECREMENT THE COUNTER
         BNE    F2              ; MOVE TO NEXT DIGIT

         MOV    10(SP),R0       ; RETURN ORIGINAL VALUE
         MOV    (SP)+,R4        ; RESTORE R4
         MOV    (SP)+,R3        ; RESTORE R3
         MOV    (SP)+,R2        ; RESTORE R2
         RTS    PC              ; RETURN TO CALLER
;
; DIVU16(DIVIDEND, DIVISOR) -> R0: QUOTIENT, R1: REMAINDER
;
; UNSIGNED 16-BIT DIVISION
;
DIVU16: MOV     4(SP),R1        ; R1 <- DIVISOR
        BNE     L0              ; IS DIVISOR ZERO?
        SEV                     ; INDICATE AN ERROR
        RTS     PC              ; RETURN TO CALLER

L0:     MOV     2(SP),R0        ; R0 <- DIVIDEND
        BNE     L1              ; IS DIVIDEND ZERO?
        CLR     R1              ; SET REMAINDER TO ZERO
        CLV                     ; INDICATE NO ERROR
        RTS     PC

L1:     MOV     R2,-(SP)        ; SAVE R2
        MOV     R3,-(SP)        ; SAVE R3
        MOV     R4,-(SP)        ; SAVE R4
        CLR     R2              ; R2 <- ACCUMULATOR
        CLR     R3              ; R3 <- RESULT
        MOV     #20,R4          ; R4 <- COUNTER

        TST     R0              ; SET N IF MSB SET
L2:     BMI     L3              ; IF N IS SET, MOVE ON
        DEC     R4              ; DECREMENT COUNTER
        ASL     R0              ; SHIFT DIVIDEND LEFT
        BR      L2              ; LOOP

L3:
        CMP     R2,R1           ; SET N IF ACCUM LESS THAN DIVISOR
        BPL     L4              ; IF N SET, GO TO L4
        ASL     R0              ; SHIFT DIVIDEND LEFT
        ROL     R2              ; ROTATE ACCUM LEFT
        ASL     R3              ; SHIFT RESULT LEFT
        DEC     R4              ; DECREMENT COUNTER
        BR      L5
L4:
        SUB     R1,R2           ; ACCUM <- ACCUM - DIVISOR
        BIS     #1,R3           ; SET RESULT LSB
L5:
        TST     R4              ; IS COUNTER ZERO?
        BNE     L3              ; IF NOT, CONTINUE

        CMP     R2,R1           ; SET N IF ACCUM LESS THAN DIVISOR
        BMI     L6              ; IF SO, MOVE ON
        SUB     R1,R2           ; ACCUM <- ACCUM - DIVISOR
        BIS     #1,R3           ; SET RESULT LSB
L6:
        MOV     R2,R1           ; REMAINDER OVERWRITES DIVISOR
        MOV     R3,R0           ; QUOTIENT OVERWRITES DIVIDEND
        MOV     +(SP),R4        ; RESTORE R4
        MOV     +(SP),R3        ; RESTORE R3
        MOV     +(SP),R2        ; RESTORE R2
        CLV                     ; NO ERROR
        RTS     PC              ; RETURN TO CALLER

        .END
